const express = require('express');
const cors = require('cors');
// const { BigQuery } = require('@google-cloud/bigquery'); // MIGRATED TO POSTGRESQL
const pool = require('./db'); // PostgreSQL connection pool
const { listAvailableDatasets, listTablesInDataset } = require('./utils');
// Google Sheets service removed - using BigQuery for teams
const path = require('path');
require('dotenv').config();

// PostgreSQL doesn't need PROJECT_ID/DATASET_ID - tables are in public schema
// const PROJECT_ID = process.env.PROJECT_ID || 'chapter-448015';
// const DATASET_ID = 'lumoviz';
const MOCK_USER_EMAIL = process.env.MOCK_USER_EMAIL || 'courtney@carolinafederation.org';

// Admin emails that get full access (checked via substring match)
const ADMIN_EMAILS = [
  'mhughes4@media.mit.edu',
  'eslin@hks.harvard.edu', 
  'emily.s.lin@gmail.com',
  'courtney@carolinafederation.org',
  'sam@carolinafederation.org',
  'ashley@carolinafederation.org'
];

const fs = require('fs');

const app = express();
// const port = process.env.PORT || 3003;
const port = process.env.PORT || 8080;

// Teams data now comes from BigQuery instead of Google Sheets

// CORS configuration
const corsOptions = {
  origin: [
    'https://lumoviz.carolinafederation.org',
    'http://localhost:3000',
    'http://localhost:3001'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin'],
  exposedHeaders: ['Content-Range', 'X-Content-Range']
};

app.use(cors(corsOptions));
app.options('*', cors(corsOptions));

app.use(express.json());

// Serve static files from the React app build directory
app.use(express.static(path.join(__dirname, 'public')));

// API health check route
app.get('/api/health', (req, res) => {
  const healthStatus = {
    message: 'Carolina Federation Symposium API Server', 
    status: 'running',
    port: port,
    timestamp: new Date().toISOString(),
    bigquery: bigquery ? 'initialized' : 'not initialized',
    environment: {
      hasCredentialsFile: fs.existsSync(process.env.GOOGLE_APPLICATION_CREDENTIALS),
    },
    endpoints: [
      '/api/chapters',
      '/api/contacts',
      '/api/idmappings',
      // '/api/links', 
      '/api/network-data',
      '/api/meetings',
      '/api/org-ids',
      // '/api/org-ids-simple',
      // '/api/analytics/events',
      '/api/teams'
    ]
  };
  
  console.log('ðŸ¥ Health check requested:', healthStatus);
  res.json(healthStatus);
});

// Analytics endpoint to store events
app.post('/api/analytics/events', async (req, res) => {
  try {
    const { events } = req.body;
    
    if (!events || !Array.isArray(events)) {
      return res.status(400).json({ error: 'Events array is required' });
    }

    // Prepare events for BigQuery insertion
    const formattedEvents = events.map(event => ({
      event_type: event.event_type,
      user_id: event.user_id || null,
      session_id: event.session_id,
      timestamp: event.timestamp,
      properties: JSON.stringify(event.properties),
      page_url: event.page_url,
      user_agent: event.user_agent,
      inserted_at: new Date().toISOString()
    }));

    // Insert into BigQuery analytics table (reuse the main bigquery client)

    await bigquery
      .dataset(DATASET_ID)
      .table('analytics_events')
      .insert(formattedEvents);
    
    // console.log(`Successfully inserted ${events.length} analytics events`);
    res.json({ success: true, eventsInserted: events.length });
    
  } catch (error) {
    console.error('Error inserting analytics events:', error);
    res.status(500).json({ error: error.message });
  }
});

// Alternative analytics endpoint for file logging
app.post('/api/analytics/log', async (req, res) => {
  try {
    const { events } = req.body;
    
    if (!events || !Array.isArray(events)) {
      return res.status(400).json({ error: 'Events array is required' });
    }

    const fs = require('fs');
    const path = require('path');
    
    // Create logs directory if it doesn't exist
    const logsDir = path.join(__dirname, 'logs');
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir);
    }

    // Create log file with current date
    const today = new Date().toISOString().split('T')[0];
    const logFile = path.join(logsDir, `analytics-${today}.log`);

    // Format events for logging
    const logEntries = events.map(event => {
      return JSON.stringify({
        ...event,
        logged_at: new Date().toISOString()
      });
    });

    // Append to log file
    fs.appendFileSync(logFile, logEntries.join('\n') + '\n');
    
    // console.log(`Successfully logged ${events.length} analytics events to ${logFile}`);
    res.json({ success: true, eventsLogged: events.length, logFile });
    
  } catch (error) {
    // console.error('Error logging analytics events:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get current user info from IAP headers
app.get('/api/user-info', (req, res) => {
  try {
    const isLocalhost = req.headers.host?.includes('localhost') || req.headers.host?.includes('127.0.0.1');
    const userJWT = req.headers['x-goog-iap-jwt-0'];
    
    if (userJWT) {
      const payload = JSON.parse(Buffer.from(userJWT.split('.')[1], 'base64').toString());
      return res.json({
        email: payload.email,
        userId: payload.sub,
        name: payload.name,
        picture: payload.picture,
        isAdmin: isAdmin(payload.email),
        environment: 'production'
      });
    }
    
    if (isLocalhost) {
      return res.json({
        email: MOCK_USER_EMAIL,
        userId: 'dev-user',
        name: MOCK_USER_EMAIL.split('@')[0],
        isAdmin: isAdmin(MOCK_USER_EMAIL),
        environment: 'development'
      });
    }
    
    res.json({ email: null, userId: null, environment: 'production' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ===== TEAMS API ENDPOINTS =====

// Test BigQuery connection for teams
app.get('/api/teams/test', async (req, res) => {
  try {
    console.log('Testing PostgreSQL teams table: lumoviz_teams');
    const query = `SELECT COUNT(*) as count FROM lumoviz_teams`;
    const result = await pool.query(query);
    const rows = result.rows;
    res.json({
      success: true,
      message: 'PostgreSQL teams table accessible',
      teamCount: rows[0].count,
      database: 'PostgreSQL - lumoviz_teams'
    });
  } catch (error) {
    console.error('Teams connection test error:', error);
    console.error('Full error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to connect to PostgreSQL teams table',
      details: error.message,
      database: 'PostgreSQL - lumoviz_teams'
    });
  }
});

// Helper function to log team changes
async function logTeamChange(teamId, changedByVanid, changedByName, fieldName, oldValue, newValue, changeReason, changeType = 'update') {
  try {
    const changeId = `change_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const query = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_team_changelog\`
      (change_id, team_id, changed_at, changed_by_vanid, changed_by_name, field_name, old_value, new_value, change_reason, change_type)
      VALUES (@changeId, @teamId, CURRENT_TIMESTAMP(), @changedByVanid, @changedByName, @fieldName, @oldValue, @newValue, @changeReason, @changeType)
    `;
    
    await bigquery.query({
      query,
      params: {
        changeId,
        teamId,
        changedByVanid: changedByVanid || null,
        changedByName: changedByName || 'System',
        fieldName,
        oldValue: oldValue || null,
        newValue: newValue || null,
        changeReason: changeReason || null,
        changeType
      }
    });
  } catch (error) {
    console.error('Error logging team change:', error);
    // Don't throw - we don't want logging errors to block the actual update
  }
}

// Get all teams from BigQuery
app.get('/api/teams', async (req, res) => {
  try {
    const query = `
      SELECT 
        id,
        team_name,
        team_leader,
        chapter,
        team_members,
        turf,
        date_created,
        date_disbanded,
        color,
        shared_purpose,
        norms,
        norm_correction,
        constituency,
        CASE WHEN date_disbanded IS NULL THEN true ELSE false END as is_active
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\`
      ORDER BY date_created DESC
    `;
    
    const [rows] = await bigquery.query(query);
    
    // Convert BigQuery results to expected format
    const teams = rows.map(row => ({
      id: row.id,
      teamName: row.team_name,
      teamLead: row.team_leader,
      chapter: row.chapter,
      teamMembers: row.team_members ? row.team_members.split(', ').filter(m => m.trim()) : [],
      turf: row.turf,
      dateCreated: row.date_created,
      dateDisbanded: row.date_disbanded,
      color: row.color,
      sharedPurpose: row.shared_purpose,
      norms: row.norms,
      normCorrection: row.norm_correction,
      constituency: row.constituency,
      isActive: row.is_active
    }));
    
    res.json({
      success: true,
      teams: teams,
      count: teams.length
    });
  } catch (error) {
    console.error('Error getting teams:', error);
    console.error('Full error details:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to get teams from BigQuery',
      details: error.message,
      dataset: `${PROJECT_ID}.${DATASET_ID}.lumoviz_teams`
    });
  }
});

// Create a new team
app.post('/api/teams', async (req, res) => {
  try {
    const { teamName, teamLead, teamLeadData, chapter, teamMembers, teamMembersData, turf, color, sharedPurpose, norms, normCorrection, constituency, createdBy, changeReason } = req.body;
    
    // Validation
    if (!teamName?.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Team name is required'
      });
    }
    
    if (!teamLead?.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Team leader is required'
      });
    }
    
    if (!chapter?.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Chapter is required'
      });
    }
    
    const teamData = {
      teamName: teamName.trim(),
      teamLead: teamLead.trim(),
      chapter: chapter.trim(),
      teamMembers: Array.isArray(teamMembers) ? teamMembers : [teamMembers].filter(Boolean),
      turf: turf?.trim() || '',
      color: color || '',
      sharedPurpose: sharedPurpose?.trim() || '',
      norms: norms?.trim() || '',
      normCorrection: normCorrection?.trim() || '',
      constituency: constituency?.trim() || ''
    };
    
    // console.log('ðŸ“ Creating new team:', teamData);
    
    // Generate unique team ID and insert into BigQuery
    const teamId = `team_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const membersString = Array.isArray(teamData.teamMembers) ? teamData.teamMembers.join(', ') : (teamData.teamMembers || '');
    const currentDate = new Date().toISOString().split('T')[0];
    
    const query = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\` 
      (id, team_name, team_leader, chapter, team_members, turf, date_created, date_disbanded, color, shared_purpose, norms, norm_correction, constituency)
      VALUES (@teamId, @teamName, @teamLead, @chapter, @teamMembers, @turf, @dateCreated, @dateDisbanded, @color, @sharedPurpose, @norms, @normCorrection, @constituency)
    `;
    
    const options = {
      query: query,
      params: {
        teamId: teamId,
        teamName: teamData.teamName,
        teamLead: teamData.teamLead,
        chapter: teamData.chapter,
        teamMembers: membersString,
        turf: teamData.turf || '',
        dateCreated: currentDate,
        dateDisbanded: null,
        color: teamData.color || '',
        sharedPurpose: teamData.sharedPurpose || '',
        norms: teamData.norms || '',
        normCorrection: teamData.normCorrection || '',
        constituency: teamData.constituency || ''
      },
      types: {
        teamId: 'STRING',
        teamName: 'STRING',
        teamLead: 'STRING',
        chapter: 'STRING',
        teamMembers: 'STRING',
        turf: 'STRING',
        dateCreated: 'DATE',
        dateDisbanded: 'STRING', // STRING for nullable DATE (BigQuery accepts null for STRING)
        color: 'STRING',
        sharedPurpose: 'STRING',
        norms: 'STRING',
        normCorrection: 'STRING',
        constituency: 'STRING'
      }
    };
    
    await bigquery.query(options);
    
    // Insert team members with roles into lumoviz_team_members table
    if (teamLeadData || (teamMembersData && teamMembersData.length > 0)) {
      const memberInserts = [];
      
      // Add team lead with roles
      if (teamLeadData && teamLeadData.id) {
        memberInserts.push({
          team_id: teamId,
          member_vanid: teamLeadData.id,
          member_name: teamLeadData.name,
          constituent_role: teamLeadData.constituentRole || null,
          functional_role: teamLeadData.functionalRole || 'Team Lead'
        });
      }
      
      // Add team members with roles
      if (teamMembersData && Array.isArray(teamMembersData)) {
        teamMembersData.forEach(member => {
          if (member.id) {
            memberInserts.push({
              team_id: teamId,
              member_vanid: member.id,
              member_name: member.name,
              constituent_role: member.constituentRole || null,
              functional_role: member.functionalRole || null
            });
          }
        });
      }
      
      // Bulk insert team members
      if (memberInserts.length > 0) {
        const memberQuery = `
          INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_team_members\`
          (team_id, member_vanid, member_name, constituent_role, functional_role, date_added, is_active)
          VALUES ${memberInserts.map(() => '(@team_id, @member_vanid, @member_name, @constituent_role, @functional_role, CURRENT_TIMESTAMP(), TRUE)').join(', ')}
        `;
        
        // Insert each member individually (BigQuery doesn't support batch inserts with different params easily)
        for (const member of memberInserts) {
          await bigquery.query({
            query: `
              INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_team_members\`
              (team_id, member_vanid, member_name, constituent_role, functional_role, date_added, is_active)
              VALUES (@team_id, @member_vanid, @member_name, @constituent_role, @functional_role, CURRENT_TIMESTAMP(), TRUE)
            `,
            params: member
          });
        }
      }
    }
    
    // Log the team creation
    await logTeamChange(
      teamId,
      createdBy?.vanid,
      createdBy?.name || 'System',
      'team_created',
      null,
      JSON.stringify({ teamName: teamData.teamName, chapter: teamData.chapter }),
      changeReason || 'Team created',
      'create'
    );
    
    const result = {
      success: true,
      teamId: teamId,
      data: {
        id: teamId,
        team_name: teamData.teamName,
        team_leader: teamData.teamLead,
        chapter: teamData.chapter,
        team_members: membersString,
        turf: teamData.turf || '',
        date_created: currentDate,
        date_disbanded: '',
        color: teamData.color || '',
        shared_purpose: teamData.sharedPurpose || '',
        norms: teamData.norms || '',
        norm_correction: teamData.normCorrection || '',
        constituency: teamData.constituency || ''
      }
    };
    
    res.json({
      success: true,
      teamId: result.teamId,
      message: 'Team created successfully',
      data: result.data
    });
    
  } catch (error) {
    console.error('Error creating team:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create team',
      details: error.message || String(error)
    });
  }
});

// Update an existing team
app.put('/api/teams/:teamId', async (req, res) => {
  try {
    const { teamId } = req.params;
    const updateData = req.body;
    const { updatedBy, changeReason } = updateData; // Extract metadata for logging
    
    if (!teamId) {
      return res.status(400).json({
        success: false,
        error: 'Team ID is required'
      });
    }
    
    // console.log(`ðŸ“ Updating team ${teamId}:`, updateData);
    
    // First, fetch current team data to track changes
    const fetchQuery = `
      SELECT * FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\`
      WHERE id = @teamId
    `;
    const [currentTeam] = await bigquery.query({ query: fetchQuery, params: { teamId } });
    
    if (currentTeam.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Team not found'
      });
    }
    
    const oldTeam = currentTeam[0];
    
    // Build dynamic UPDATE query based on provided fields
    const updateFields = [];
    const params = { teamId };
    const fieldMap = {}; // Track old vs new for logging
    
    if (updateData.teamName !== undefined) {
      updateFields.push('team_name = @teamName');
      params.teamName = updateData.teamName;
      fieldMap.team_name = { old: oldTeam.team_name, new: updateData.teamName };
    }
    if (updateData.teamLead !== undefined) {
      updateFields.push('team_leader = @teamLead');
      params.teamLead = updateData.teamLead;
      fieldMap.team_leader = { old: oldTeam.team_leader, new: updateData.teamLead };
    }
    if (updateData.chapter !== undefined) {
      updateFields.push('chapter = @chapter');
      params.chapter = updateData.chapter;
      fieldMap.chapter = { old: oldTeam.chapter, new: updateData.chapter };
    }
    if (updateData.teamMembers !== undefined) {
      const membersString = Array.isArray(updateData.teamMembers) ? updateData.teamMembers.join(', ') : updateData.teamMembers;
      updateFields.push('team_members = @teamMembers');
      params.teamMembers = membersString;
      fieldMap.team_members = { old: oldTeam.team_members, new: membersString };
    }
    if (updateData.turf !== undefined) {
      updateFields.push('turf = @turf');
      params.turf = updateData.turf;
      fieldMap.turf = { old: oldTeam.turf, new: updateData.turf };
    }
    if (updateData.color !== undefined) {
      updateFields.push('color = @color');
      params.color = updateData.color;
      fieldMap.color = { old: oldTeam.color, new: updateData.color };
    }
    if (updateData.sharedPurpose !== undefined) {
      updateFields.push('shared_purpose = @sharedPurpose');
      params.sharedPurpose = updateData.sharedPurpose;
      fieldMap.shared_purpose = { old: oldTeam.shared_purpose, new: updateData.sharedPurpose };
    }
    if (updateData.norms !== undefined) {
      updateFields.push('norms = @norms');
      params.norms = updateData.norms;
      fieldMap.norms = { old: oldTeam.norms, new: updateData.norms };
    }
    if (updateData.normCorrection !== undefined) {
      updateFields.push('norm_correction = @normCorrection');
      params.normCorrection = updateData.normCorrection;
      fieldMap.norm_correction = { old: oldTeam.norm_correction, new: updateData.normCorrection };
    }
    if (updateData.constituency !== undefined) {
      updateFields.push('constituency = @constituency');
      params.constituency = updateData.constituency;
      fieldMap.constituency = { old: oldTeam.constituency, new: updateData.constituency };
    }
    if (updateData.dateDisbanded !== undefined) {
      updateFields.push('date_disbanded = @dateDisbanded');
      params.dateDisbanded = updateData.dateDisbanded;
      fieldMap.date_disbanded = { old: oldTeam.date_disbanded, new: updateData.dateDisbanded };
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No fields to update'
      });
    }
    
    // Perform the update
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\` 
      SET ${updateFields.join(', ')}
      WHERE id = @teamId
    `;
    
    await bigquery.query({ query, params });
    
    // Log each changed field
    for (const [fieldName, values] of Object.entries(fieldMap)) {
      if (values.old !== values.new) {
        await logTeamChange(
          teamId,
          updatedBy?.vanid,
          updatedBy?.name || 'System',
          fieldName,
          values.old,
          values.new,
          changeReason,
          'update'
        );
      }
    }
    
    // Update organizer details (roles and turfs) if provided
    if (updateData.organizerDetails && Array.isArray(updateData.organizerDetails)) {
      for (const organizer of updateData.organizerDetails) {
        if (organizer.id) {
          try {
            // Use vanid if it looks like a vanid, otherwise try to find it
            const vanid = organizer.id;
            
            const updateOrgQuery = `
              UPDATE \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
              SET 
                team_role = @teamRole,
                turf = @turf
              WHERE vanid = @vanid
            `;
            
            await bigquery.query({
              query: updateOrgQuery,
              params: {
                vanid: vanid,
                teamRole: organizer.team_role || null,
                turf: organizer.turf || null
              }
            });
            
            console.log(`âœ… Updated organizer ${organizer.name} (${vanid}): role=${organizer.team_role}, turf=${organizer.turf}`);
          } catch (orgError) {
            console.error(`âŒ Error updating organizer ${organizer.name}:`, orgError);
            // Don't fail the whole request if one organizer update fails
          }
        }
      }
    }
    
    const result = { success: true, teamId };
    
    res.json({
      success: true,
      teamId: teamId,
      message: 'Team updated successfully'
    });
    
  } catch (error) {
    console.error('Error updating team:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update team',
      details: error.message
    });
  }
});

// Disband a team (set date_disbanded)
app.patch('/api/teams/:teamId/disband', async (req, res) => {
  try {
    const { teamId } = req.params;
    const { disbandedBy, changeReason } = req.body;
    const currentDate = new Date().toISOString().split('T')[0];
    
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\`
      SET date_disbanded = @dateDisbanded
      WHERE id = @teamId
    `;
    
    const options = {
      query: query,
      params: {
        teamId: teamId,
        dateDisbanded: currentDate
      },
      types: {
        teamId: 'STRING',
        dateDisbanded: 'STRING'
      }
    };
    
    await bigquery.query(options);
    
    // Log the disbandment
    await logTeamChange(
      teamId,
      disbandedBy?.vanid,
      disbandedBy?.name || 'System',
      'date_disbanded',
      null,
      currentDate,
      changeReason || 'Team disbanded',
      'disband'
    );
    
    res.json({
      success: true,
      message: 'Team disbanded successfully',
      teamId: teamId,
      dateDisbanded: currentDate
    });
    
  } catch (error) {
    console.error('Error disbanding team:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to disband team',
      details: error.message || String(error)
    });
  }
});

// Get changelog for a team
app.get('/api/teams/:teamId/changelog', async (req, res) => {
  try {
    const { teamId } = req.params;
    
    if (!teamId) {
      return res.status(400).json({
        success: false,
        error: 'Team ID is required'
      });
    }
    
    const query = `
      SELECT 
        change_id,
        team_id,
        changed_at,
        changed_by_vanid,
        changed_by_name,
        field_name,
        old_value,
        new_value,
        change_reason,
        change_type
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_team_changelog\`
      WHERE team_id = @teamId
      ORDER BY changed_at DESC
    `;
    
    const [rows] = await bigquery.query({ query, params: { teamId } });
    
    res.json({
      success: true,
      changelog: rows
    });
    
  } catch (error) {
    console.error('Error fetching team changelog:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch team changelog',
      details: error.message
    });
  }
});

// Delete a team completely
app.delete('/api/teams/:teamId', async (req, res) => {
  try {
    const { teamId } = req.params;
    
    const query = `
      DELETE FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\`
      WHERE id = @teamId
    `;
    
    const options = {
      query: query,
      params: {
        teamId: teamId
      },
      types: {
        teamId: 'STRING'
      }
    };
    
    await bigquery.query(options);
    
    res.json({
      success: true,
      message: 'Team deleted successfully',
      teamId: teamId
    });
    
  } catch (error) {
    console.error('Error deleting team:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete team',
      details: error.message || String(error)
    });
  }
});

// Update chapter color
app.put('/api/chapters/:chapterName/color', async (req, res) => {
  try {
    const { chapterName } = req.params;
    const { color } = req.body;
    
    if (!chapterName) {
      return res.status(400).json({
        success: false,
        error: 'Chapter name is required'
      });
    }
    
    if (!color) {
      return res.status(400).json({
        success: false,
        error: 'Color is required'
      });
    }
    
    // console.log(`ðŸŽ¨ Updating color for chapter ${chapterName} to ${color}`);
    
    // Update color for all teams in this chapter
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\` 
      SET color = @color
      WHERE chapter = @chapter
    `;
    
    const [job] = await bigquery.query({
      query,
      params: { color, chapter: chapterName }
    });
    
    // Get the number of affected rows
    const stats = job.statistics;
    const updatedCount = stats && stats.dmlStats ? stats.dmlStats.updatedRowCount : 0;
    
    const result = { 
      success: true, 
      updatedCount: parseInt(updatedCount) || 0,
      chapter: chapterName,
      color: color
    };
    
    res.json({
      success: true,
      message: `Color updated for chapter ${chapterName}`,
      updatedCount: result.updatedCount,
      teams: result.teams
    });
    
  } catch (error) {
    console.error('Error updating chapter color:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update chapter color',
      details: error.message
    });
  }
});

// Delete (disband) a team
app.delete('/api/teams/:teamId', async (req, res) => {
  try {
    const { teamId } = req.params;
    
    if (!teamId) {
      return res.status(400).json({
        success: false,
        error: 'Team ID is required'
      });
    }
    
    // console.log(`ðŸ—‘ï¸ Disbanding team ${teamId}`);
    
    // Mark team as disbanded instead of deleting
    const currentDate = new Date().toISOString().split('T')[0];
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\` 
      SET date_disbanded = @dateDisbanded
      WHERE id = @teamId
    `;
    
    await bigquery.query({
      query,
      params: { 
        teamId: teamId,
        dateDisbanded: currentDate
      }
    });
    
    const result = { success: true, teamId };
    
    res.json({
      success: true,
      teamId: teamId,
      message: 'Team disbanded successfully'
    });
    
  } catch (error) {
    // console.error('Error disbanding team:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to disband team',
      details: error.message
    });
  }
});

// ===== END TEAMS API ENDPOINTS =====

// ===== TURF LIST API ENDPOINTS =====

// Add person to turf list (My Turf)
app.post('/api/turf-list', async (req, res) => {
  try {
    const { organizee, organizeeVanid, organizer, organizerVanid, action } = req.body;
    
    // Validation
    if (!organizee?.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Organizee name is required'
      });
    }
    
    if (!organizeeVanid) {
      return res.status(400).json({
        success: false,
        error: 'Organizee VAN ID is required'
      });
    }
    
    if (!organizer?.trim()) {
      return res.status(400).json({
        success: false,
        error: 'Organizer name is required'
      });
    }
    
    if (!organizerVanid) {
      return res.status(400).json({
        success: false,
        error: 'Organizer VAN ID is required'
      });
    }
    
    // Check if this entry already exists
    const checkQuery = `
      SELECT COUNT(*) as count
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_lists\`
      WHERE organizee_vanid = @organizeeVanid
        AND organizer_vanid = @organizerVanid
        AND action = @action
    `;
    
    const checkOptions = {
      query: checkQuery,
      params: {
        organizeeVanid: organizeeVanid,
        organizerVanid: organizerVanid.toString(),
        action: action || 'pledges'
      }
    };
    
    const [checkResults] = await bigquery.query(checkOptions);
    
    if (checkResults[0].count > 0) {
      return res.json({
        success: true,
        message: 'Entry already exists',
        alreadyExists: true
      });
    }
    
    // Insert into lumoviz_lists
    const insertQuery = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_lists\` 
      (organizee, organizee_vanid, organizer, organizer_vanid, action)
      VALUES (@organizee, @organizeeVanid, @organizer, @organizerVanid, @action)
    `;
    
    const insertOptions = {
      query: insertQuery,
      params: {
        organizee: organizee.trim(),
        organizeeVanid: organizeeVanid,
        organizer: organizer.trim(),
        organizerVanid: organizerVanid.toString(),
        action: action || 'pledges'
      },
      types: {
        organizee: 'STRING',
        organizeeVanid: 'INT64',
        organizer: 'STRING',
        organizerVanid: 'STRING',
        action: 'STRING'
      }
    };
    
    await bigquery.query(insertOptions);
    
    res.json({
      success: true,
      message: 'Person added to turf list successfully',
      data: {
        organizee: organizee.trim(),
        organizeeVanid: organizeeVanid,
        organizer: organizer.trim(),
        organizerVanid: organizerVanid.toString(),
        action: action || 'pledges'
      }
    });
    
  } catch (error) {
    console.error('Error adding to turf list:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to add to turf list',
      details: error.message || String(error)
    });
  }
});

// ===== END TURF LIST API ENDPOINTS =====

// Route to list available datasets
app.get('/api/datasets', async (req, res) => {
  try {
    const datasets = await listAvailableDatasets();
    res.json(datasets);
  } catch (error) {
    // console.error('Error listing datasets:', error);
    res.status(500).json({ error: error.message });
  }
});

// Route to list tables in a dataset
app.get('/api/tables/:dataset', async (req, res) => {
  try {
    const { dataset } = req.params;
    const tables = await listTablesInDataset(dataset);
    res.json(tables);
  } catch (error) {
    // console.error('Error listing tables:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===== MIGRATED TO POSTGRESQL =====
// BigQuery initialization removed - now using PostgreSQL connection pool from db.js
// The pool is automatically initialized when required
console.log('âœ… Using PostgreSQL database connection');

// ===== ORGANIZATIONAL ACCESS CONTROL FUNCTIONS =====

// Cache for org structure to avoid repeated queries
let orgStructureCache = null;
let orgCacheTimestamp = null;
const ORG_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// Function to get the complete organizational structure
async function getOrgStructure() {
  const now = Date.now();
  
  // Return cached data if it's still fresh
  if (orgStructureCache && orgCacheTimestamp && (now - orgCacheTimestamp) < ORG_CACHE_TTL) {
    return orgStructureCache;
  }
  
  try {
    // console.log('Fetching organizational structure from BigQuery...');
    
    const query = `
      SELECT 
        userid,
        vanid,
        supervisorid,
        firstname,
        lastname,
        type,
        turf,
        team_role
      FROM \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      WHERE userid IS NOT NULL
    `;
    
    const [rows] = await bigquery.query({ query, location: 'US' });
    
    // Create maps for quick lookups
    const orgStructure = {
      userToSupervisor: new Map(), // userid -> supervisorid
      supervisorToUsers: new Map(), // supervisorid -> [userids]
      userToVanid: new Map(),      // userid -> vanid
      vanidToUser: new Map(),      // vanid -> userid
      userInfo: new Map()          // userid -> user info
    };
    
    rows.forEach(row => {
      const userid = row.userid?.toString();
      const vanid = row.vanid?.toString();
      const supervisorid = row.supervisorid?.toString();
      
      if (userid) {
        // Map user to supervisor
        if (supervisorid) {
          orgStructure.userToSupervisor.set(userid, supervisorid);
          
          // Map supervisor to users
          if (!orgStructure.supervisorToUsers.has(supervisorid)) {
            orgStructure.supervisorToUsers.set(supervisorid, []);
          }
          orgStructure.supervisorToUsers.get(supervisorid).push(userid);
        }
        
        // Map user to vanid and vice versa
        if (vanid) {
          orgStructure.userToVanid.set(userid, vanid);
          orgStructure.vanidToUser.set(vanid, userid);
        }
        
        // Store user info
        orgStructure.userInfo.set(userid, {
          userid,
          vanid,
          supervisorid,
          firstname: row.firstname,
          lastname: row.lastname,
          type: row.type
        });
      }
    });
    
    // Cache the structure
    orgStructureCache = orgStructure;
    orgCacheTimestamp = now;
    
    // console.log(`Loaded org structure: ${orgStructure.userInfo.size} users, ${orgStructure.supervisorToUsers.size} supervisors`);
    
    return orgStructure;
  } catch (error) {
    console.error('Error fetching org structure:', error);
    return null;
  }
}

// Get all accessible user/van IDs for a given user based on org hierarchy
async function getAccessibleIds(loggedInUserId) {
  const orgStructure = await getOrgStructure();
  if (!orgStructure) return new Set();
  
  const accessibleIds = new Set();
  
  function addSubordinates(supervisorId) {
    accessibleIds.add(supervisorId);
    const vanid = orgStructure.userToVanid.get(supervisorId);
    if (vanid) accessibleIds.add(vanid);
    const subordinates = orgStructure.supervisorToUsers.get(supervisorId) || [];
    subordinates.forEach(addSubordinates);
  }
  
  addSubordinates(loggedInUserId);
  return accessibleIds;
}

// Get user ID from email, userid, or vanid
async function getUserIdFromIdentifier(identifier) {
  if (!identifier) return null;
  try {
    const query = `
      SELECT userid FROM \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      WHERE userid = '${identifier}' OR vanid = '${identifier}'
        OR LOWER(CONCAT(firstname, '@carolinafederation.org')) = LOWER('${identifier}')
      LIMIT 1`;
    const [rows] = await bigquery.query({ query, location: 'US' });
    return rows[0]?.userid?.toString() || null;
  } catch { return null; }
}

// Check if email is an admin
function isAdmin(email) {
  if (!email) return false;
  return ADMIN_EMAILS.some(admin => email.includes(admin));
}

// Get all IDs for admin access
async function getAllAccessibleIds() {
  const allIds = new Set();
  const orgStructure = await getOrgStructure();
  if (orgStructure) {
    orgStructure.userInfo.forEach((info, id) => {
      allIds.add(id);
      if (info.vanid) allIds.add(info.vanid);
    });
  }
  try {
    const [rows] = await bigquery.query({ 
      query: `SELECT DISTINCT CAST(vanid AS STRING) as vanid FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` WHERE vanid IS NOT NULL`,
      location: 'US'
    });
    rows.forEach(row => row.vanid && allIds.add(row.vanid));
  } catch {}
  return allIds;
}

// Middleware to check data access permissions
async function checkDataAccess(req, res, next) {
  try {
    const isLocalhost = req.headers.host?.includes('localhost') || req.headers.host?.includes('127.0.0.1');
    
    // Get user email from IAP headers or use mock for local dev
    let userEmail = isLocalhost 
      ? MOCK_USER_EMAIL 
      : (req.headers['x-goog-authenticated-user-email'] || req.headers['x-goog-iap-jwt-0']);
    
    // Clean up email (remove accounts.google.com: prefix if present)
    if (userEmail?.includes(':')) userEmail = userEmail.split(':').pop();
    
    const actualUserId = await getUserIdFromIdentifier(userEmail);
    
    // Admin users get full access
    if (isAdmin(userEmail)) {
      req.accessibleIds = await getAllAccessibleIds();
      req.hasDataAccess = true;
      req.currentUserId = actualUserId || 'admin';
      return next();
    }
    
    // Regular users get hierarchical access
    if (actualUserId) {
      req.accessibleIds = await getAccessibleIds(actualUserId);
      req.hasDataAccess = true;
      req.currentUserId = actualUserId;
    } else {
      req.accessibleIds = new Set();
      req.hasDataAccess = true;
      req.currentUserId = 'unknown';
    }
    next();
  } catch {
    req.accessibleIds = new Set();
    req.hasDataAccess = false;
    next();
  }
}

// ============================================================

// Get chapters endpoint
// Chapters are inferred from the lumoviz_teams table
app.get('/api/chapters', async (req, res) => {
  try {
    console.log(`Attempting to query chapters from ${PROJECT_ID}.${DATASET_ID}.lumoviz_teams`);
    
    const query = `
      SELECT DISTINCT chapter
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_teams\`
      WHERE chapter IS NOT NULL AND chapter != ''
      ORDER BY chapter
    `;

    console.log('Executing query:', query);

    const options = {
      query,
      location: 'US',
    };

    const [rows] = await bigquery.query(options);
    console.log(`Successfully retrieved ${rows.length} chapters`);
    
    res.json(rows.map(row => row.chapter));
  } catch (error) {
    console.error('Error fetching chapters:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get contacts from lumoviz.contacts table with pagination, filtering, sorting
// Supports ordering by most recent contact date with time window prioritization
app.get('/api/contacts', async (req, res) => {
  try {
    const { 
      chapter, 
      member_status,
      loe,
      search,
      organizer,  // New: filter by organizer name
      sortBy = 'mostRecentContact',  // Default to most recent contact (reverse chronological)
      sortOrder = 'DESC',
      limit = 100,
      offset = 0,
      start_date,
      end_date
    } = req.query;
    
    const params = {};
    let whereConditions = ['c.vanid IS NOT NULL'];
    
    // Filter out "ghost" contacts: those with no membership status, no name, AND never contacted
    // Include contacts that have at least ONE of: membership status, first name, last name, or have been contacted
    whereConditions.push(`(
      (c.member_status IS NOT NULL AND c.member_status != '')
      OR (c.first_name IS NOT NULL AND TRIM(c.first_name) != '')
      OR (c.last_name IS NOT NULL AND TRIM(c.last_name) != '')
      OR EXISTS (
        SELECT 1 FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv 
        WHERE CAST(conv.participant_vanid AS STRING) = CAST(c.vanid AS STRING)
      )
    )`);
    
    // Chapter filter (supports partial match for text filter)
    if (chapter && chapter !== 'All' && chapter !== 'All Chapters') {
      whereConditions.push('LOWER(c.chapter) LIKE LOWER(@chapter)');
      params.chapter = `%${chapter}%`;
    }
    
    // Member status filter (supports comma-separated values for multi-select)
    if (member_status) {
      const statuses = member_status.split(',').map(s => s.trim());
      const statusConditions = [];
      
      statuses.forEach((status, index) => {
        if (status === 'null') {
          // Filter for contacts with no membership status
          statusConditions.push('(c.member_status IS NULL OR c.member_status = "")');
        } else {
          const paramName = `member_status_${index}`;
          statusConditions.push(`c.member_status = @${paramName}`);
          params[paramName] = status;
        }
      });
      
      if (statusConditions.length > 0) {
        whereConditions.push(`(${statusConditions.join(' OR ')})`);
      }
    }
    
    // LOE filter (supports comma-separated values for multi-select)
    if (loe) {
      const loeValues = loe.split(',').map(s => s.trim());
      const loeConditions = [];
      
      loeValues.forEach((loeValue, index) => {
        const paramName = `loe_${index}`;
        loeConditions.push(`c.loe = @${paramName}`);
        params[paramName] = loeValue;
      });
      
      if (loeConditions.length > 0) {
        whereConditions.push(`(${loeConditions.join(' OR ')})`);
      }
    }
    
    // Organizer filter (contacts organized by a specific person)
    if (organizer) {
      console.log('[/api/contacts] Filtering by organizer:', organizer);
      whereConditions.push(`EXISTS (
        SELECT 1 FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
        WHERE CAST(conv.participant_vanid AS STRING) = CAST(c.vanid AS STRING)
        AND (
          LOWER(CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) LIKE LOWER(@organizer)
        )
      )`);
      params.organizer = `%${organizer}%`;
    }
    
    // Search filter (name, email)
    if (search) {
      whereConditions.push(`(
        LOWER(c.first_name) LIKE LOWER(@search) OR 
        LOWER(c.last_name) LIKE LOWER(@search) OR 
        LOWER(c.email) LIKE LOWER(@search) OR
        LOWER(CONCAT(c.first_name, ' ', c.last_name)) LIKE LOWER(@search)
      )`);
      params.search = `%${search}%`;
    }
    
    const whereClause = whereConditions.join(' AND ');
    
    // Determine if we should order by most recent contact
    const orderByRecentContact = sortBy === 'mostRecentContact';
    
    if (orderByRecentContact) {
      // Complex query that joins with contact_history to get most recent meeting date
      // Orders by: 1) within time window (most recent first), 2) outside window (most recent first)
      const hasTimeWindow = start_date && end_date;
      
      // Get total count (from base contacts table)
      const countQuery = `
        SELECT COUNT(*) as total
        FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        WHERE ${whereClause}
      `;
      
      const [countResult] = await bigquery.query({ 
        query: countQuery, 
        location: 'US',
        params 
      });
      const total = countResult[0]?.total || 0;
      
      // Build the main query with left join to get most recent contact date
      // Using the conversations table which has participant_vanid and date_contacted
      let dataQuery;
      
      if (hasTimeWindow) {
        params.start_date = start_date;
        params.end_date = end_date;
        
        // Build CTE with optional organizer filter - also aggregate organizer names
        const cteQuery = organizer ? `
          WITH contact_meetings AS (
            SELECT 
              CAST(conv.participant_vanid AS STRING) as contact_vanid,
              MAX(conv.date_contacted) as last_contact_date,
              COUNT(*) as total_meetings,
              STRING_AGG(DISTINCT CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, '')), ', ' ORDER BY CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) as organizers
            FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
            LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
              ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
            WHERE conv.participant_vanid IS NOT NULL
              AND LOWER(CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) LIKE LOWER(@organizer)
            GROUP BY CAST(conv.participant_vanid AS STRING)
          )` : `
          WITH contact_meetings AS (
            SELECT 
              CAST(conv.participant_vanid AS STRING) as contact_vanid,
              MAX(conv.date_contacted) as last_contact_date,
              COUNT(*) as total_meetings,
              STRING_AGG(DISTINCT CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, '')), ', ' ORDER BY CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) as organizers
            FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
            LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
              ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
            WHERE conv.participant_vanid IS NOT NULL
            GROUP BY CAST(conv.participant_vanid AS STRING)
          )`;
        
        dataQuery = `
          ${cteQuery}
          SELECT 
            c.vanid,
            c.first_name,
            c.last_name,
            c.chapter,
            c.email,
            c.member_status,
            c.loe,
            cm.last_contact_date,
            COALESCE(cm.total_meetings, 0) as total_meetings_all_time,
            cm.organizers,
            CASE 
              WHEN cm.last_contact_date >= @start_date AND cm.last_contact_date <= @end_date THEN 1
              ELSE 0
            END as in_window
          FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
          LEFT JOIN contact_meetings cm ON CAST(c.vanid AS STRING) = cm.contact_vanid
          WHERE ${whereClause}
          ORDER BY cm.last_contact_date DESC NULLS LAST
          LIMIT @limit
          OFFSET @offset
        `;
      } else {
        // No time window - just order by most recent contact
        const cteQuery = organizer ? `
          WITH contact_meetings AS (
            SELECT 
              CAST(conv.participant_vanid AS STRING) as contact_vanid,
              MAX(conv.date_contacted) as last_contact_date,
              COUNT(*) as total_meetings,
              STRING_AGG(DISTINCT CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, '')), ', ' ORDER BY CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) as organizers
            FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
            LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
              ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
            WHERE conv.participant_vanid IS NOT NULL
              AND LOWER(CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) LIKE LOWER(@organizer)
            GROUP BY CAST(conv.participant_vanid AS STRING)
          )` : `
          WITH contact_meetings AS (
            SELECT 
              CAST(conv.participant_vanid AS STRING) as contact_vanid,
              MAX(conv.date_contacted) as last_contact_date,
              COUNT(*) as total_meetings,
              STRING_AGG(DISTINCT CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, '')), ', ' ORDER BY CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) as organizers
            FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
            LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
              ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
            WHERE conv.participant_vanid IS NOT NULL
            GROUP BY CAST(conv.participant_vanid AS STRING)
          )`;
        
        dataQuery = `
          ${cteQuery}
          SELECT 
            c.vanid,
            c.first_name,
            c.last_name,
            c.chapter,
            c.email,
            c.member_status,
            c.loe,
            cm.last_contact_date,
            COALESCE(cm.total_meetings, 0) as total_meetings_all_time,
            cm.organizers
          FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
          LEFT JOIN contact_meetings cm ON CAST(c.vanid AS STRING) = cm.contact_vanid
          WHERE ${whereClause}
          ORDER BY cm.last_contact_date DESC NULLS LAST
          LIMIT @limit
          OFFSET @offset
        `;
      }
      
      const [rows] = await bigquery.query({ 
        query: dataQuery, 
        location: 'US',
        params: {
          ...params,
          limit: parseInt(limit),
          offset: parseInt(offset)
        }
      });
      
      res.json({
        data: rows,
        pagination: {
          total,
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: parseInt(offset) + rows.length < total
        }
      });
    } else {
      // Simple query without contact history join
      // Validate sort column to prevent SQL injection
      const validSortColumns = ['first_name', 'last_name', 'chapter', 'member_status', 'loe', 'email'];
      const safeSortBy = validSortColumns.includes(sortBy) ? sortBy : 'last_name';
      const safeSortOrder = sortOrder.toUpperCase() === 'DESC' ? 'DESC' : 'ASC';
      
      // Get total count
      const countQuery = `
        SELECT COUNT(*) as total
        FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        WHERE ${whereClause}
      `;
      
      const [countResult] = await bigquery.query({ 
        query: countQuery, 
        location: 'US',
        params 
      });
      const total = countResult[0]?.total || 0;
      
      // Get paginated data with meeting counts
      const cteQuery = organizer ? `
        WITH contact_meetings AS (
          SELECT 
            CAST(conv.participant_vanid AS STRING) as contact_vanid,
            MAX(conv.date_contacted) as last_contact_date,
            COUNT(*) as total_meetings,
            STRING_AGG(DISTINCT CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, '')), ', ' ORDER BY CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) as organizers
          FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
          LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
            ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
          WHERE conv.participant_vanid IS NOT NULL
            AND LOWER(CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) LIKE LOWER(@organizer)
          GROUP BY CAST(conv.participant_vanid AS STRING)
        )` : `
        WITH contact_meetings AS (
          SELECT 
            CAST(conv.participant_vanid AS STRING) as contact_vanid,
            MAX(conv.date_contacted) as last_contact_date,
            COUNT(*) as total_meetings,
            STRING_AGG(DISTINCT CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, '')), ', ' ORDER BY CONCAT(COALESCE(org_contact.first_name, ''), ' ', COALESCE(org_contact.last_name, ''))) as organizers
          FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
          LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
            ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
          WHERE conv.participant_vanid IS NOT NULL
          GROUP BY CAST(conv.participant_vanid AS STRING)
        )`;
      
      const dataQuery = `
        ${cteQuery}
        SELECT 
          c.vanid,
          c.first_name,
          c.last_name,
          c.chapter,
          c.email,
          c.member_status,
          c.loe,
          cm.last_contact_date,
          COALESCE(cm.total_meetings, 0) as total_meetings_all_time,
          cm.organizers
        FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        LEFT JOIN contact_meetings cm ON CAST(c.vanid AS STRING) = cm.contact_vanid
        WHERE ${whereClause}
        ORDER BY ${safeSortBy} ${safeSortOrder}, c.last_name ASC
        LIMIT @limit
        OFFSET @offset
      `;
      
      const [rows] = await bigquery.query({ 
        query: dataQuery, 
        location: 'US',
        params: {
          ...params,
          limit: parseInt(limit),
          offset: parseInt(offset)
        }
      });
      
      res.json({
        data: rows,
        pagination: {
          total,
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: parseInt(offset) + rows.length < total
        }
      });
    }
  } catch (error) {
    console.error('Error fetching contacts:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get LOE counts for Kanban - returns total count by LOE status
app.get('/api/contacts/loe-counts', async (req, res) => {
  try {
    const { chapter, member_status, search } = req.query;
    
    const params = {};
    let whereConditions = ['c.vanid IS NOT NULL'];
    
    // Filter out "ghost" contacts (same logic as main contacts endpoint)
    whereConditions.push(`(
      (c.member_status IS NOT NULL AND c.member_status != '')
      OR (c.first_name IS NOT NULL AND TRIM(c.first_name) != '')
      OR (c.last_name IS NOT NULL AND TRIM(c.last_name) != '')
      OR EXISTS (
        SELECT 1 FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv 
        WHERE CAST(conv.participant_vanid AS STRING) = CAST(c.vanid AS STRING)
      )
    )`);
    
    // Chapter filter
    if (chapter && chapter !== 'All' && chapter !== 'All Chapters') {
      whereConditions.push('LOWER(c.chapter) LIKE LOWER(@chapter)');
      params.chapter = `%${chapter}%`;
    }
    
    // Member status filter
    if (member_status) {
      const statuses = member_status.split(',').map(s => s.trim());
      const statusConditions = [];
      
      statuses.forEach((status, index) => {
        if (status === 'null') {
          statusConditions.push('(c.member_status IS NULL OR c.member_status = "")');
        } else {
          const paramName = `member_status_${index}`;
          statusConditions.push(`c.member_status = @${paramName}`);
          params[paramName] = status;
        }
      });
      
      if (statusConditions.length > 0) {
        whereConditions.push(`(${statusConditions.join(' OR ')})`);
      }
    }
    
    // Search filter
    if (search) {
      whereConditions.push(`(
        LOWER(c.first_name) LIKE LOWER(@search) OR 
        LOWER(c.last_name) LIKE LOWER(@search) OR 
        LOWER(c.email) LIKE LOWER(@search) OR
        LOWER(CONCAT(c.first_name, ' ', c.last_name)) LIKE LOWER(@search)
      )`);
      params.search = `%${search}%`;
    }
    
    const whereClause = whereConditions.join(' AND ');
    
    // Query to count contacts by LOE status
    const query = `
      SELECT 
        COALESCE(c.loe, 'Unknown') as loe_status,
        COUNT(*) as count
      FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
      WHERE ${whereClause}
      GROUP BY c.loe
      ORDER BY c.loe
    `;
    
    const options = {
      query,
      location: 'US',
      params
    };
    
    const [rows] = await bigquery.query(options);
    
    // Transform results into a more usable format
    const counts = {
      total: 0,
      by_loe: {}
    };
    
    rows.forEach(row => {
      const loeStatus = row.loe_status || 'Unknown';
      const count = parseInt(row.count);
      counts.by_loe[loeStatus] = count;
      counts.total += count;
    });
    
    res.json(counts);
  } catch (error) {
    console.error('Error fetching LOE counts:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get id mappings
app.get('/api/idmappings', async (req, res) => {
  try {
    // First, let's list the column names to see what's available
    const columnsQuery = `
      SELECT column_name, data_type
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'staff'
    `;

    const [columns] = await bigquery.query({ query: columnsQuery, location: 'US' });
    
    // console.log('Staff table columns:', columns.map(col => col.column_name));
    
    // Now query with correct column names
    const query = `
      SELECT 
        UserID, 
        VANID,
        first_name as firstName, 
        last_name as lastName
      FROM \`${PROJECT_ID}.${DATASET_ID}.staff\`
    `;

    const options = {
      query,
      location: 'US',
    };

    const [rows] = await bigquery.query(options);
    // console.log(`Retrieved ${rows.length} ID mappings`);
    
    res.json(rows);
  } catch (error) {
    // console.error('Error fetching ID mappings:', error);
    
    // If we can't get columns, try a fallback query with likely column names
    try {
      // console.log('Trying fallback query for staff table...');
      const fallbackQuery = `
        SELECT 
          UserID,
          VANID,
          first_name as firstName,
          last_name as lastName
        FROM \`${PROJECT_ID}.${DATASET_ID}.staff\`
        LIMIT 1000
      `;
      
      const [fallbackRows] = await bigquery.query({ query: fallbackQuery, location: 'US' });
      // console.log(`Retrieved ${fallbackRows.length} ID mappings with fallback query`);
      
      res.json(fallbackRows);
    } catch (fallbackError) {
      // console.error('Fallback query also failed:', fallbackError);
      res.status(500).json({ error: error.message });
    }
  }
});

// Get links with filtering options
app.get('/api/links', async (req, res) => {
  // console.log('Links API called with query params:', req.query);
  try {
    // Set a limit for the number of rows returned
    const limit = req.query.limit ? parseInt(req.query.limit) : 1000;

    // Query from the links table which only has userid, vanid, total
    const query = `
      SELECT 
        userid,
        vanid,
        total
      FROM \`${PROJECT_ID}.${DATASET_ID}.links\`
      LIMIT ${limit}
    `;

    // console.log('Executing query:', query);

    const options = {
      query,
      location: 'US',
    };

    const [rows] = await bigquery.query(options);
    // console.log(`Retrieved ${rows.length} rows from links table`);
    
    // Log the first row structure to see all columns
    if (rows.length > 0) {
      // console.log('Links table structure:', Object.keys(rows[0]));
      // console.log('Sample row:', JSON.stringify(rows[0], null, 2));
    }
    
    // Map the response to match the expected API format
    // Add placeholder values for missing fields
    const mappedRows = rows.map(row => ({
      userId: row.userid ? row.userid.toString() : '',
      vanId: row.vanid ? row.vanid.toString() : '',
      count: row.total ? row.total.toString() : '1',
      // Add placeholder values for missing fields
      contact_type: 'In-Person',  // Default placeholder
      contact_result: 'Successful', // Default placeholder
      utc_datecanvassed: new Date().toISOString(), // Use current date
      source: row.userid ? row.userid.toString() : '',
      target: row.vanid ? row.vanid.toString() : '',
      source_chapter: 'Unknown',
      target_chapter: 'Unknown'
    }));
    
    // console.log(`Returning ${mappedRows.length} processed rows`);
    res.json(mappedRows);
  } catch (error) {
    // console.error('Error fetching links:', error);
    res.status(500).json({ error: error.message, stack: error.stack });
  }
});

// Get available contact types
app.get('/api/contactTypes', async (req, res) => {
  try {
    // First check if contact_type exists in links table
    const columnsQuery = `
      SELECT column_name
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'links' AND column_name = 'contact_type'
    `;
    
    const [columns] = await bigquery.query({ query: columnsQuery, location: 'US' });
    
    if (columns.length > 0) {
      const query = `
        SELECT DISTINCT contact_type
        FROM \`${PROJECT_ID}.${DATASET_ID}.links\`
        WHERE contact_type IS NOT NULL
        ORDER BY contact_type
      `;

      const options = {
        query,
        location: 'US',
      };

      const [rows] = await bigquery.query(options);
      res.json(rows.map(row => row.contact_type));
    } else {
      // If contact_type doesn't exist, return default values
      // console.log('contact_type column not found in links table, returning default values');
      res.json(['In-Person', 'Phone', 'Email', 'Text']);
    }
  } catch (error) {
    // console.error('Error fetching contact types:', error);
    // Return default values if query fails
    res.json(['In-Person', 'Phone', 'Email', 'Text']);
  }
});

// Get available contact results
app.get('/api/contactResults', async (req, res) => {
  try {
    // First check if contact_result exists in links table
    const columnsQuery = `
      SELECT column_name
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'links' AND column_name = 'contact_result'
    `;
    
    const [columns] = await bigquery.query({ query: columnsQuery, location: 'US' });
    
    if (columns.length > 0) {
      const query = `
        SELECT DISTINCT contact_result
        FROM \`${PROJECT_ID}.${DATASET_ID}.links\`
        WHERE contact_result IS NOT NULL
        ORDER BY contact_result
      `;

      const options = {
        query,
        location: 'US',
      };

      const [rows] = await bigquery.query(options);
      res.json(rows.map(row => row.contact_result));
    } else {
      // If contact_result doesn't exist, return default values
      // console.log('contact_result column not found in links table, returning default values');
      res.json(['Successful', 'Left Message', 'No Answer', 'Wrong Number']);
    }
  } catch (error) {
    // console.error('Error fetching contact results:', error);
    // Return default values if query fails
    res.json(['Successful', 'Left Message', 'No Answer', 'Wrong Number']);
  }
});

// Add a new endpoint to check contact_history table structure
app.get('/api/contact-history-info', async (req, res) => {
  try {
    // console.log('Retrieving contact_history table information...');
    
    // First get the table schema
    const columnsQuery = `
      SELECT column_name, data_type
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'contact_history'
      ORDER BY ordinal_position
    `;

    const [columns] = await bigquery.query({ query: columnsQuery, location: 'US' });
    
    // console.log('Contact History Columns:');
    columns.forEach(col => {
      // console.log(`- ${col.column_name} (${col.data_type})`);
    });
    
    // Query sample data
    const dataQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.contact_history\`
      LIMIT 10
    `;

    const [rows] = await bigquery.query({ query: dataQuery, location: 'US' });
    
    // console.log(`Retrieved ${rows.length} sample rows`);
    
    // Check if there are any date columns
    const dateColumns = columns.filter(col => 
      col.data_type.toLowerCase().includes('date') || 
      col.data_type.toLowerCase().includes('time') ||
      col.column_name.toLowerCase().includes('date') ||
      col.column_name.toLowerCase().includes('time')
    );
    
    // Check for common columns with links table
    const linksColumnsQuery = `
      SELECT column_name
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'links'
    `;
    
    const [linksColumns] = await bigquery.query({ query: linksColumnsQuery, location: 'US' });
    const linksColumnNames = linksColumns.map(col => col.column_name);
    const contactHistoryColumnNames = columns.map(col => col.column_name);
    
    const commonColumns = linksColumnNames.filter(col => 
      contactHistoryColumnNames.includes(col)
    );
    
    // Return all the collected information
    res.json({
      columns: columns,
      sampleData: rows,
      dateColumns: dateColumns,
      commonColumnsWithLinks: commonColumns
    });
  } catch (error) {
    // console.error('Error fetching contact history info:', error);
    res.status(500).json({ error: error.message });
  }
});

// First, let's add a base API route
app.get('/api', (req, res) => {
  res.json({ message: 'API is running', routes: ['/api/links', '/api/contacts', '/api/contactTypes', '/api/contactResults', '/api/contact-history'] });
});

// Add a new endpoint to get links from contact_history table
app.get('/api/contact-history', async (req, res) => {
  try {
    // console.log('Contact History API called with query params:', req.query);
    
    // First check if the table exists and get its schema
    const columnsQuery = `
      SELECT column_name, data_type
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'contact_history'
      ORDER BY ordinal_position
    `;

    const [columns] = await bigquery.query({ query: columnsQuery, location: 'US' });
    
    if (columns.length === 0) {
      return res.status(404).json({ error: 'Contact history table not found' });
    }
    
    // console.log('Contact History Columns:', columns.map(col => col.column_name).join(', '));
    
    // Check for date columns
    const dateColumns = columns.filter(col => 
      col.data_type.toLowerCase().includes('date') || 
      col.data_type.toLowerCase().includes('time') ||
      col.column_name.toLowerCase().includes('date') ||
      col.column_name.toLowerCase().includes('time')
    );
    
    // console.log('Date columns found:', dateColumns.map(col => col.column_name).join(', '));
    
    // Build query based on schema
    let query = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.contact_history\`
    `;
    
    // Add a LIMIT for safety
    const limit = req.query.limit ? parseInt(req.query.limit) : 1000;
    query += `\nLIMIT ${limit}`;

    // console.log('Executing query:', query);

    const [rows] = await bigquery.query({ query, location: 'US' });
    // console.log(`Retrieved ${rows.length} rows from contact_history table`);
    
    // Log the first row structure
    if (rows.length > 0) {
      // console.log('First row sample:', JSON.stringify(rows[0], null, 2));
    }
    
    res.json({
      tableInfo: {
        columns: columns.map(col => ({ name: col.column_name, type: col.data_type })),
        dateColumns: dateColumns.map(col => ({ name: col.column_name, type: col.data_type }))
      },
      data: rows
    });
  } catch (error) {
    // console.error('Error fetching contact history:', error);
    res.status(500).json({ error: error.message, stack: error.stack });
  }
});

// Add a new endpoint to get links with dates by joining with contact_history
app.get('/api/links-with-dates', async (req, res) => {
  try {
    // console.log('Links with dates API called with query params:', req.query);
    
    // Extract parameters
    const { startDate, endDate, chapter } = req.query;
    const limit = req.query.limit ? parseInt(req.query.limit) : 1000;
    
    // Build WHERE clause for filtering
    let whereClause = '';
    
    // Date filtering
    if (startDate) {
      whereClause += `\nWHERE ch.utc_datecanvassed >= TIMESTAMP('${startDate}')`;
    }
    
    if (endDate) {
      whereClause += whereClause ? `\nAND ch.utc_datecanvassed <= TIMESTAMP('${endDate}')` :
        `\nWHERE ch.utc_datecanvassed <= TIMESTAMP('${endDate}')`;
    }
    
    // Chapter filtering - build a different query if chapter is specified
    let query;
    
    if (chapter && chapter !== 'All Chapters') {
      // If we have a chapter filter, we need to join with the contacts table
      query = `
        SELECT 
          l.userid,
          l.vanid,
          l.total,
          ch.utc_datecanvassed,
          ch.contact_type,
          ch.contact_result,
          ch.input_source,
          c.chapter as target_chapter
        FROM 
          \`${PROJECT_ID}.${DATASET_ID}.links\` l
        JOIN
          \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
        ON
          l.vanid = ch.vanid
        LEFT JOIN
          \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        ON
          l.vanid = c.vanid
        WHERE 
          ${whereClause ? whereClause.replace('WHERE ', '') + ' AND' : ''} 
          c.chapter = '${chapter}'
        ORDER BY ch.utc_datecanvassed DESC
        LIMIT ${limit}
      `;
    } else {
      // Default query without chapter filtering
      query = `
        SELECT 
          l.userid,
          l.vanid,
          l.total,
          ch.utc_datecanvassed,
          ch.contact_type,
          ch.contact_result,
          ch.input_source
        FROM 
          \`${PROJECT_ID}.${DATASET_ID}.links\` l
        JOIN
          \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
        ON
          l.vanid = ch.vanid
        ${whereClause}
        ORDER BY ch.utc_datecanvassed DESC
        LIMIT ${limit}
      `;
    }
    
    // console.log('Executing query:', query);
    
    const [rows] = await bigquery.query({ query, location: 'US' });
    // console.log(`Retrieved ${rows.length} rows from links with dates query`);
    
    // Log the first row for debugging
    if (rows.length > 0) {
      // console.log('First row sample:', JSON.stringify(rows[0], null, 2));
    }
    
    // Map the response to match the expected API format
    const mappedRows = rows.map(row => ({
      userid: row.userid ? row.userid.toString() : '',
      vanid: row.vanid ? row.vanid.toString() : '',
      total: row.total || 1,
      contact_type: row.contact_type || 'Unknown',
      contact_result: row.contact_result || 'Unknown',
      utc_datecanvassed: row.utc_datecanvassed?.value || new Date().toISOString(),
      source: row.userid ? row.userid.toString() : '',
      target: row.vanid ? row.vanid.toString() : '',
      source_chapter: 'Unknown',
      target_chapter: row.target_chapter || 'Unknown',
      input_source: row.input_source || 'Unknown'
    }));
    
    // console.log(`Returning ${mappedRows.length} processed rows`);
    res.json(mappedRows);
  } catch (error) {
    // console.error('Error fetching links with dates:', error);
    res.status(500).json({ error: error.message, stack: error.stack });
  }
});

// Get staff endpoint
app.get('/api/staff', async (req, res) => {
  try {
    const query = `
      SELECT 
        UserID,
        VANID,
        first_name as firstName,
        last_name as lastName
      FROM \`${PROJECT_ID}.${DATASET_ID}.staff\`
      LIMIT 1000
    `;

    const options = {
      query,
      location: 'US',
    };

    const [rows] = await bigquery.query(options);
    // console.log(`Retrieved ${rows.length} staff records`);
    
    res.json(rows);
  } catch (error) {
    // console.error('Error fetching staff:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add a new endpoint to get network data directly from contact_history with access control
app.get('/api/contact-history-network', checkDataAccess, async (req, res) => {
  try {
    // console.log('Contact History Network API called with query params:', req.query);
    
    // Extract parameters
    const { start_date, end_date, chapter, sample: sampleParam, page = 0, limit = 1000 } = req.query;
    const sample = sampleParam === 'true'; // Whether to use sampling
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    
    // Build WHERE clause for filtering
    let whereClause = '';
    
    // Date filtering
    if (start_date) {
      whereClause += `\nWHERE ch.utc_datecanvassed >= TIMESTAMP('${start_date}')`;
    }
    
    if (end_date) {
      whereClause += whereClause ? `\nAND ch.utc_datecanvassed <= TIMESTAMP('${end_date}')` :
        `\nWHERE ch.utc_datecanvassed <= TIMESTAMP('${end_date}')`;
    }
    
    // Chapter filtering - add if chapter is specified
    if (chapter && chapter !== 'All Chapters') {
      whereClause += whereClause 
        ? `\nAND c.chapter = '${chapter}'` 
        : `\nWHERE c.chapter = '${chapter}'`;
    }
    
    // Build the query to get direct data from contact_history WITHOUT joining staff table
    let query;
    
    if (sample) {
      // Use a more efficient sampling technique with window functions
      query = `
        WITH SampledContacts AS (
          SELECT 
            ch.userid,
            ch.vanid,
            ch.username,
            ch.utc_datecanvassed,
            ch.contact_type,
            ch.contact_result,
            ch.input_source,
            ROW_NUMBER() OVER (PARTITION BY ch.userid, ch.vanid ORDER BY ch.utc_datecanvassed DESC) as row_num
          FROM 
            \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
          LEFT JOIN
            \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
          ON
            ch.vanid = c.vanid
          ${whereClause}
        )
        SELECT 
          sc.userid,
          sc.vanid,
          sc.username,
          sc.utc_datecanvassed,
          sc.contact_type,
          sc.contact_result,
          sc.input_source,
          c.firstname as target_first_name,
          c.lastname as target_last_name,
          c.chapter as target_chapter
        FROM 
          SampledContacts sc
        LEFT JOIN
          \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        ON
          sc.vanid = c.vanid
        WHERE
          sc.row_num = 1  -- Only get the most recent contact between each pair
        ORDER BY sc.utc_datecanvassed DESC
      `;
    } else {
      // Original query without staff join
      query = `
        SELECT 
          ch.userid,
          ch.vanid,
          ch.username,
          ch.utc_datecanvassed,
          ch.contact_type,
          ch.contact_result,
          ch.input_source,
          c.firstname as target_first_name,
          c.lastname as target_last_name,
          c.chapter as target_chapter,
          um.firstname as organizer_first_name,
          um.lastname as organizer_last_name
        FROM 
          \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
        LEFT JOIN
          \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        ON
          ch.vanid = c.vanid
        LEFT JOIN
          \`${PROJECT_ID}.${DATASET_ID}.user_map\` um
        ON
          ch.userid = um.userid
        ${whereClause}
        ORDER BY ch.utc_datecanvassed DESC
        LIMIT ${limitNum} OFFSET ${pageNum * limitNum}
      `;
    }
    
    // console.log('Executing query:', query);
    
    const [rows] = await bigquery.query({ query, location: 'US' });
    // console.log(`Retrieved ${rows.length} rows from contact_history for network graph`);
    
    // Log the first row for debugging
    if (rows.length > 0) {
      // console.log('First row sample:', JSON.stringify(rows[0], null, 2));
    }
    
    // If we got no results from the specific date range, 
    // use a fallback query with a broader date range to ensure we return something
    if (rows.length === 0) {
      // console.log('No data found for specified date range, using fallback query...');
      
      const fallbackQuery = `
        SELECT 
          ch.userid,
          ch.vanid,
          ch.username,
          ch.utc_datecanvassed,
          ch.contact_type,
          ch.contact_result,
          ch.input_source,
          c.firstname as target_first_name,
          c.lastname as target_last_name,
          c.chapter as target_chapter
        FROM 
          \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
        LEFT JOIN
          \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        ON
          ch.vanid = c.vanid
        WHERE ch.userid IS NOT NULL
        AND ch.vanid IS NOT NULL
        ORDER BY ch.utc_datecanvassed DESC
      `;
      
      const [fallbackRows] = await bigquery.query({ query: fallbackQuery, location: 'US' });
      // console.log(`Retrieved ${fallbackRows.length} rows from fallback query`);
    
    // Map the response to match the expected API format
      const mappedRows = fallbackRows.map(row => {
        // Extract and format IDs with proper string conversion
        const userid = row.userid ? row.userid.toString() : '';
        const vanid = row.vanid ? row.vanid.toString() : '';
        
        // If either ID is missing, log a warning
        if (!userid || !vanid) {
          console.log('Warning: Fallback record with missing ID:', row);
        }
        
        return {
          userid,
          vanid,
      username: row.username || '',
          source_name: row.username || `User ${userid}`,
      target_name: row.target_first_name && row.target_last_name 
        ? `${row.target_first_name} ${row.target_last_name}` 
            : `Contact ${vanid}`,
          source_chapter: 'Unknown', // Default value since we don't have this in the query
          target_chapter: row.target_chapter || 'Unknown',
          // Use the specified date range even though data is from a different range
          utc_datecanvassed: start_date ? new Date(start_date).toISOString() : new Date().toISOString(),
      contact_type: row.contact_type || 'Unknown',
      contact_result: row.contact_result || 'Unknown',
          input_source: row.input_source || 'Unknown'
        };
      }).filter(row => row.userid && row.vanid); // Filter out any rows with missing IDs
      
      // console.log(`Returning ${mappedRows.length} processed rows from fallback query`);
      
      // Log a sample of the IDs for debugging
      if (mappedRows.length > 0) {
        console.log('Sample IDs from first 3 fallback rows:');
        mappedRows.slice(0, 3).forEach((row, idx) => {
          // console.log(`Row ${idx}: userid=${row.userid}, vanid=${row.vanid}`);
        });
      }
      
      return res.json(mappedRows);
    }
    
    // Apply access control - show all nodes but filter sensitive data
    let processedRows = rows;
    
    if (req.hasDataAccess && req.accessibleIds.size > 0) {
      // Don't filter out rows - show all connections
      // But we'll mark which ones have restricted access for data filtering
      processedRows = rows.map(row => {
        const userid = row.userid?.toString();
        const vanid = row.vanid?.toString();
        
        // User can see full details if they have access to EITHER the organizer (userid) OR the contact (vanid)
        const hasOrganizerAccess = req.accessibleIds.has(userid);
        const hasContactAccess = req.accessibleIds.has(vanid);
        const hasFullAccess = hasOrganizerAccess || hasContactAccess;
        
        return {
          ...row,
          hasFullAccess // Mark whether user can see full details
        };
      });
      
      // console.log(`Access control applied: showing all ${processedRows.length} contact history records, with access restrictions based on org hierarchy for user ${req.currentUserId}`);
    } else {
      // console.log('No access control applied - user has no verified org access');
      processedRows = []; // No access if user not found in org structure
    }

    // Map the response to match the expected API format
    const mappedRows = processedRows.map(row => {
      // Extract and format IDs with proper string conversion
      const userid = row.userid ? row.userid.toString() : '';
      const vanid = row.vanid ? row.vanid.toString() : '';
      
      // If either ID is missing, log a warning
      if (!userid || !vanid) {
        // console.log('Warning: Record with missing ID:', row);
      }
      
      // If user doesn't have full access, hide sensitive information
      const hasFullAccess = row.hasFullAccess !== false; // Default to true if not set
      
      return {
        userid,
        vanid,
        username: hasFullAccess ? (row.username || '') : 'Restricted',
        source_name: hasFullAccess ? (row.username || `User ${userid}`) : 'Restricted User',
        target_name: hasFullAccess && row.target_first_name && row.target_last_name
          ? `${row.target_first_name} ${row.target_last_name}`
          : hasFullAccess ? `Contact ${vanid}` : 'Restricted Contact',
        source_chapter: hasFullAccess ? 'Unknown' : 'Restricted', // Default value since we don't have this in the query
        target_chapter: hasFullAccess ? (row.target_chapter || 'Unknown') : 'Restricted',
        utc_datecanvassed: row.utc_datecanvassed ? row.utc_datecanvassed.value || row.utc_datecanvassed : new Date().toISOString(),
        contact_type: hasFullAccess ? (row.contact_type || 'Unknown') : 'Restricted',
        contact_result: hasFullAccess ? (row.contact_result || 'Unknown') : 'Restricted',
        input_source: hasFullAccess ? (row.input_source || 'Unknown') : 'Restricted',
        hasFullAccess // Include this flag for frontend use
      };
    }).filter(row => row.userid && row.vanid); // Filter out any rows with missing IDs
    
    // console.log(`Returning ${mappedRows.length} processed rows after access control`);
    
    // Log a sample of the IDs for debugging
    if (mappedRows.length > 0) {
      // console.log('Sample accessible IDs from first 3 rows:');
      mappedRows.slice(0, 3).forEach((row, idx) => {
        // console.log(`Row ${idx}: userid=${row.userid}, vanid=${row.vanid}`);
      });
    }
    
    res.json(mappedRows);
  } catch (error) {
    // console.error('Error fetching contact history network data:', error);
    
    // Even if we encounter an error, return some sample data for the frontend
    // console.log('Returning sample data due to error...');
    
    // Generate some sample data
    const sampleData = [];
    for (let i = 0; i < 20; i++) {
      const userId = (1000 + i).toString();
      const vanId = (100000 + i).toString();
      
      sampleData.push({
        userid: userId,
        vanid: vanId,
        username: `sample_user_${i}`,
        source_name: `Sample User ${i}`,
        target_name: `Sample Contact ${i}`,
        source_chapter: 'Sample Chapter',
        target_chapter: 'Sample Chapter',
        utc_datecanvassed: new Date().toISOString(),
        contact_type: ['Phone', 'In-Person', 'Email'][i % 3],
        contact_result: ['Successful', 'Left Message', 'No Answer'][i % 3],
        input_source: 'Sample Data'
      });
    }
    
    // Log sample IDs for debugging
    // console.log('Sample IDs from generated data:');
    sampleData.slice(0, 3).forEach((row, idx) => {
      // console.log(`Row ${idx}: userid=${row.userid}, vanid=${row.vanid}`);
    });
    
    res.json(sampleData);
  }
});

// Add a new endpoint to get date range from contact_history
app.get('/api/contact-history-date-range', async (req, res) => {
  try {
    // console.log('Retrieving contact_history date range...');
    
    // Query to get min and max dates
    const query = `
      SELECT 
        MIN(utc_datecanvassed) as min_date,
        MAX(utc_datecanvassed) as max_date
      FROM 
        \`${PROJECT_ID}.${DATASET_ID}.contact_history\`
      WHERE 
        utc_datecanvassed IS NOT NULL
    `;

    const [result] = await bigquery.query({ query, location: 'US' });
    
    if (result.length === 0) {
      return res.status(404).json({ error: 'No date range found' });
    }
    
    // Format the dates
    const minDate = result[0].min_date ? result[0].min_date.value : null;
    const maxDate = result[0].max_date ? result[0].max_date.value : null;
    
    // console.log(`Date range found: ${minDate} to ${maxDate}`);
    
    res.json({
      min_date: minDate,
      max_date: maxDate
    });
  } catch (error) {
    // console.error('Error fetching contact history date range:', error);
    
    // Return a fallback date range that supports the 3-month default
    const now = new Date();
    const fallbackMinDate = new Date(now);
    fallbackMinDate.setFullYear(fallbackMinDate.getFullYear() - 2); // 2 years back
    
    res.json({ 
      min_date: fallbackMinDate.toISOString(), 
      max_date: now.toISOString(),
      fallback: true
    });
  }
});

// Get network data endpoint
app.post('/api/network-data', async (req, res) => {
  try {
    const { start_date, end_date, chapter, showApiUsers, showAdmins, adminUserIds } = req.body;
    // console.log('Network data request:', { start_date, end_date, chapter, showApiUsers, showAdmins });

    let whereClause = `WHERE ch.utc_datecanvassed >= '${start_date}' AND ch.utc_datecanvassed <= '${end_date}'`;
    
    // Add chapter filter if provided
    if (chapter && chapter !== 'All Chapters') {
      whereClause += ` AND c.chapter = '${chapter}'`;
    }
    
    // Filter out API users if requested
    if (showApiUsers === false) {
      whereClause += ` AND (um.api_user IS NULL OR um.api_user = false)`;
    }
    
    // Filter out admin users if requested
    if (showAdmins === false && adminUserIds && adminUserIds.length > 0) {
      const adminIdsStr = adminUserIds.join(',');
      whereClause += ` AND ch.userid NOT IN (${adminIdsStr}) AND ch.vanid NOT IN (${adminIdsStr})`;
    }

    const query = `
      SELECT 
        ch.userid,
        ch.vanid,
        ch.username,
        ch.utc_datecanvassed,
        ch.contact_type,
        ch.contact_result,
        ch.input_source,
        c.firstname as target_first_name,
        c.lastname as target_last_name,
        c.chapter as target_chapter,
        c.loe as target_loe,
        um.firstname as organizer_first_name,
        um.lastname as organizer_last_name
      FROM 
        \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
      ON
        ch.vanid = c.vanid
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.user_map\` um
      ON
        ch.userid = um.userid
      ${whereClause}
      ORDER BY ch.utc_datecanvassed DESC
    `;

    // console.log('Executing query:', query);

    const options = {
      query,
      location: 'US',
    };

    const [rows] = await bigquery.query(options);
    // console.log(`Retrieved ${rows.length} rows from contact_history for network graph`);
    
    if (rows.length > 0) {
      // console.log('First row sample:', rows[0]);
    }
    
    res.json(rows);
  } catch (error) {
    // console.error('Error fetching network data:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add a new endpoint to get org_ids data
app.get('/api/org-ids', async (req, res) => {
  try {
    // console.log('Fetching org_ids data...');
    
    // First check the schema to see what columns are available
    const schemaQuery = `
      SELECT column_name, data_type
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'org_ids'
      ORDER BY ordinal_position
    `;
    
    const [columns] = await bigquery.query({ query: schemaQuery, location: 'US' });
    // console.log('Org_ids columns:', columns.map(col => col.column_name).join(', '));
    
    // Look for ID fields that could match the userID in nodes
    const idColumns = columns.filter(col => 
      col.column_name.toLowerCase().includes('id') ||
      col.column_name.toLowerCase().includes('user') ||
      col.column_name.toLowerCase().includes('van')
    );
    
    // console.log('Potential ID columns:', idColumns.map(col => col.column_name).join(', '));
    
    // Build the column list for the SELECT query
    let selectColumns = ['vanid'];
    
    // Add any other ID columns we found
    idColumns.forEach(col => {
      if (!selectColumns.includes(col.column_name)) {
        selectColumns.push(col.column_name);
      }
    });
    
    // Add name columns
    if (columns.find(col => col.column_name === 'firstname')) {
      selectColumns.push('firstname');
    }
    if (columns.find(col => col.column_name === 'lastname')) {
      selectColumns.push('lastname');
    }
    if (columns.find(col => col.column_name === 'email')) {
      selectColumns.push('email');
    }
    if (columns.find(col => col.column_name === 'chapter')) {
      selectColumns.push('chapter');
    }
    
    // Query the org_ids table with the columns we found
    const query = `
      SELECT 
        ${selectColumns.join(',\n        ')}
      FROM \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      LIMIT 2000
    `;

    // console.log('Executing query:', query);
    const [rows] = await bigquery.query({ query, location: 'US' });
    
    // console.log(`Retrieved ${rows.length} rows from org_ids table`);
    if (rows.length > 0) {
      // console.log('First row sample:', JSON.stringify(rows[0], null, 2));
    }
    
    res.json({
      columns: columns,
      idColumns: idColumns,
      data: rows
    });
  } catch (error) {
    // console.error('Error fetching org_ids data:', error);
    res.status(500).json({ error: error.message });
  }
});

// Simplified endpoint for org_ids to ensure we can access the data
app.get('/api/org-ids-simple', async (req, res) => {
  try {
    // console.log('Fetching org_ids data (simple)...');
    
    // Simple direct query of the org_ids table
    const query = `
      SELECT 
        vanid,
        userid,
        firstname,
        lastname,
        supervisorid,
        type,
        turf,
        team_role
        -- email,
        -- chapter
      FROM \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      LIMIT 5000
    `;

    // console.log('Executing org_ids query:', query);
    const [rows] = await bigquery.query({ query, location: 'US' });
    
    // console.log(`Retrieved ${rows.length} rows from org_ids table (simple endpoint)`);
    if (rows.length > 0) {
      // console.log('First row sample:', JSON.stringify(rows[0], null, 2));
    }
    
    // Return direct results without wrapping in an object
    res.json(rows);
  } catch (error) {
    // console.error('Error fetching org_ids data:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get conversations endpoint
app.get('/api/conversations-schema', async (req, res) => {
  try {
    // console.log('Checking conversations table schema...');
    
    const schemaQuery = `
      SELECT column_name, data_type
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'conversations'
      ORDER BY ordinal_position
    `;
    
    const [columns] = await bigquery.query({ query: schemaQuery, location: 'US' });
    // console.log('Conversations columns:', columns.map(col => col.column_name).join(', '));
    
    // Also get a sample row
    const sampleQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\`
      LIMIT 3
    `;
    
    const [rows] = await bigquery.query({ query: sampleQuery, location: 'US' });
    
    res.json({
      columns: columns,
      sampleData: rows
    });
  } catch (error) {
    // console.error('Error checking conversations schema:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get conversations endpoint with access control (also aliased as /api/meetings for backward compatibility)
app.get('/api/conversations', checkDataAccess, async (req, res) => {
  try {
    const { startDate, endDate, chapter, participant, page = 0, limit = 50000 } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    
    // console.log(`/api/conversations called with: startDate=${startDate}, endDate=${endDate}, chapter=${chapter}, participant=${participant}, limit=${limitNum}`);
    
    // Build base query using conversations table with contacts for LOE data
    // NOTE: Names come from org_ids first, then contacts table as fallback (NOT from conversations)
    let query = `
      WITH ConversationsData AS (
        SELECT 
          c.organizer_vanid,
          -- Organizer name: try org_ids first, then contacts, then 'Unknown Organizer'
          COALESCE(
            NULLIF(TRIM(CONCAT(COALESCE(o1.firstname, ''), ' ', COALESCE(o1.lastname, ''))), ''),
            NULLIF(TRIM(CONCAT(COALESCE(cont2.first_name, ''), ' ', COALESCE(cont2.last_name, ''))), ''),
            'Unknown Organizer'
          ) as organizer,
          c.participant_vanid as vanid,
          c.date_contacted as datestamp,
          c.participant_chapter as chapter,
          c.conversation_type as meeting_type,
          c.purpose as notes_purpose,
          c.commitments as notes_commitments,
          c.stakes as notes_stakes,
          '' as notes_development,
          c.evaluation as notes_evaluation,
          -- Two-on-One meeting fields - host name: try org_ids first, then contacts
          CASE WHEN c.host_vanid IS NOT NULL THEN 
            COALESCE(
              NULLIF(TRIM(CONCAT(COALESCE(o3.firstname, ''), ' ', COALESCE(o3.lastname, ''))), ''),
              NULLIF(TRIM(CONCAT(COALESCE(cont3.first_name, ''), ' ', COALESCE(cont3.last_name, ''))), ''),
              'Unknown Host'
            )
          ELSE NULL END as host_oneonone,
          c.host_vanid,
          c.host_email,
          '' as two_risks,
          '' as two_effective,
          '' as two_support,
          -- Contact information (participant) - use contacts table for participant info
          COALESCE(cont1.first_name, c.participant_first_name) as contact_firstname,
          COALESCE(cont1.last_name, c.participant_last_name) as contact_lastname,
          c.participant_chapter as contact_chapter,
          cont1.loe as contact_loe,
          cont1.member_status as member_status,
          cont1.email as email,
          -- Organizer information - try org_ids first, then contacts
          COALESCE(o1.firstname, cont2.first_name) as organizer_firstname,
          COALESCE(o1.lastname, cont2.last_name) as organizer_lastname,
          cont2.chapter as organizer_chapter,
          cont2.loe as organizer_loe,
          -- Host information (for Two-on-One meetings) - try org_ids first, then contacts
          COALESCE(o3.firstname, cont3.first_name) as host_firstname,
          COALESCE(o3.lastname, cont3.last_name) as host_lastname,
          cont3.chapter as host_chapter,
          cont3.loe as host_loe,
          -- Include org_ids info for access control
          o1.userid as organizer_userid,
          o2.userid as contact_userid,
          o3.userid as host_userid
        FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` c
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont1 
          ON CAST(c.participant_vanid AS STRING) = CAST(cont1.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont2 
          ON CAST(c.organizer_vanid AS STRING) = CAST(cont2.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont3 
          ON CAST(c.host_vanid AS STRING) = CAST(cont3.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o1
          ON CAST(c.organizer_vanid AS STRING) = CAST(o1.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o2
          ON CAST(c.participant_vanid AS STRING) = CAST(o2.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o3
          ON CAST(c.host_vanid AS STRING) = CAST(o3.vanid AS STRING)
        WHERE 1=1
      `;

    // Add date filters
    if (startDate) {
      query += ` AND DATE(c.date_contacted) >= DATE('${startDate}')`;
    }
    if (endDate) {
      query += ` AND DATE(c.date_contacted) <= DATE('${endDate}')`;
    }
    if (chapter && chapter !== 'All Chapters') {
      // Include conversations where EITHER the participant OR organizer is from the selected chapter
      query += ` AND (c.participant_chapter = '${chapter}' OR cont2.chapter = '${chapter}')`;
    }
    if (participant) {
      // Filter by specific participant VAN ID - cast to STRING for comparison
      query += ` AND CAST(c.participant_vanid AS STRING) = '${participant}'`;
    }


    query += `)
      SELECT * FROM ConversationsData
      ORDER BY datestamp DESC
      LIMIT ${limitNum} OFFSET ${pageNum * limitNum}
    `;

    // console.log('Executing conversations query with access control...');


    const [rows] = await bigquery.query({ query, location: 'US' });
    // console.log(`Retrieved ${rows.length} rows from conversations table before access filtering`);
    
    // Debug: Show date range of retrieved data
    if (rows.length > 0) {
      const dates = rows.map(row => {
        // Handle BigQuery date objects
        const date = row.datestamp;
        if (date && typeof date === 'object' && date.value) {
          return date.value;
        }
        return date;
      }).filter(Boolean).sort();
      
      const minDate = dates[0];
      const maxDate = dates[dates.length - 1];
      // console.log(`Date range in retrieved data: ${minDate} to ${maxDate}`);
      // console.log(`Sample dates: ${dates.slice(0, 5).join(', ')}`);
      // console.log(`Total unique dates: ${new Set(dates.map(d => d.split('T')[0])).size}`);
      
      // Check if we're hitting the limit and if data is only recent
      const daysDiff = Math.ceil((new Date(maxDate) - new Date(minDate)) / (1000 * 60 * 60 * 24));
      // console.log(`Actual date span in data: ${daysDiff} days`);
      if (rows.length === limitNum) {
        // console.log(`âš ï¸  WARNING: Hit the limit of ${limitNum} rows. Data might be truncated to recent dates only.`);
      }
    }
    
    // Debug Two-on-One meeting host data
    const twoOnOneMeetings = rows.filter(row => row.meeting_type === 'Two-on-One');
    if (twoOnOneMeetings.length > 0) {
      console.log('Sample Two-on-One meeting raw data from BigQuery:');
      const sample = twoOnOneMeetings[0];
      console.log({
        meeting_type: sample.meeting_type,
        host_vanid: sample.host_vanid,
        host_firstname: sample.host_firstname,
        host_lastname: sample.host_lastname,
        host_chapter: sample.host_chapter,
        organizer: sample.organizer,
        organizer_vanid: sample.organizer_vanid
      });
    }
    
    // Apply access control - show all meetings but filter sensitive notes
    let processedRows = rows;
    
    if (req.hasDataAccess) {
      // If user has data access but no specific accessible IDs, show all meetings with restricted notes
      const hasSpecificAccess = req.accessibleIds.size > 0;
      // console.log(`Has specific access: ${hasSpecificAccess}`);
      processedRows = rows.map(row => {
        const organizerVanId = row.organizer_vanid?.toString();
        const contactVanId = row.vanid?.toString();
        const hostVanId = row.host_vanid?.toString();
        const organizerUserId = row.organizer_userid?.toString();
        const contactUserId = row.contact_userid?.toString();
        const hostUserId = row.host_userid?.toString();
        
        // User can see full meeting details if they have access to the organizer, contact, OR host
        const hasOrganizerAccess = hasSpecificAccess && (req.accessibleIds.has(organizerVanId) || 
                                  req.accessibleIds.has(organizerUserId));
        const hasContactAccess = hasSpecificAccess && (req.accessibleIds.has(contactVanId) || 
                                req.accessibleIds.has(contactUserId));
        const hasHostAccess = hasSpecificAccess && hostVanId && (req.accessibleIds.has(hostVanId) || 
                             req.accessibleIds.has(hostUserId));
        // If user has no specific access (accessibleIds.size = 0), show all meetings but with restricted notes
        // If user has specific access, only show meetings they have access to
        const hasFullAccess = hasSpecificAccess ? (hasOrganizerAccess || hasContactAccess || hasHostAccess) : true;
        
        // For Two-on-One meetings, allow host name access if user has access to host, contact, or organizer
        // Note: organizer_vanid is often null for Two-on-One meetings, so we're more permissive with host names
        const hasTwoOnOneNotesAccess = row.meeting_type === 'Two-on-One' ? 
          (hasOrganizerAccess || hasContactAccess || hasHostAccess) : hasFullAccess;
        
        // Debug access control for Two-on-One meetings
        // if (row.meeting_type === 'Two-on-One') {
        //   console.log(`Two-on-One access control debug for host_vanid ${hostVanId}:`);
        //   console.log(`  Current user: ${req.currentUserId}`);
        //   console.log(`  hasOrganizerAccess: ${hasOrganizerAccess} (organizer: ${organizerVanId}/${organizerUserId})`);
        //   console.log(`  hasContactAccess: ${hasContactAccess} (contact: ${contactVanId}/${contactUserId})`);
        //   console.log(`  hasHostAccess: ${hasHostAccess} (host: ${hostVanId}/${hostUserId})`);
        //   console.log(`  hasFullAccess: ${hasFullAccess}`);
        //   console.log(`  hasTwoOnOneNotesAccess: ${hasTwoOnOneNotesAccess}`);
        //   console.log(`  Accessible IDs count: ${req.accessibleIds.size}`);
        // }
        
        return {
          ...row,
          hasFullAccess, // Mark whether user can see full details including notes
          hasTwoOnOneNotesAccess // Mark whether user can see Two-on-One specific notes
        };
      });
      
      // console.log(`Access control applied: showing all ${processedRows.length} conversations, with note restrictions based on org hierarchy for user ${req.currentUserId}`);
    } else {
      // console.log('No data access - user has no verified access');
      processedRows = []; // No access if user has no data access at all
    }
    
    // Remove the internal userid fields and apply access control to sensitive fields
    const cleanedRows = processedRows.map(row => {
      const { organizer_userid, contact_userid, host_userid, hasFullAccess, hasTwoOnOneNotesAccess, ...cleanedRow } = row;
      
      // If user doesn't have full access, hide meeting notes
      if (!hasFullAccess) {
        return {
          ...cleanedRow,
          notes_purpose: 'Restricted - No Access',
          notes_commitments: 'Restricted - No Access',
          notes_stakes: 'Restricted - No Access',
          notes_development: 'Restricted - No Access',
          notes_evaluation: 'Restricted - No Access',
          // Two-on-One specific notes access is controlled separately
          host_oneonone: cleanedRow.host_oneonone || false,
          host_vanid: cleanedRow.host_vanid || null,
          host_email: hasTwoOnOneNotesAccess ? cleanedRow.host_email : 'Restricted - No Access',
          two_risks: hasTwoOnOneNotesAccess ? cleanedRow.two_risks : 'Restricted - No Access',
          two_effective: hasTwoOnOneNotesAccess ? cleanedRow.two_effective : 'Restricted - No Access',
          two_support: hasTwoOnOneNotesAccess ? cleanedRow.two_support : 'Restricted - No Access',
          // Always show host names for Two-on-One meetings (basic organizational info, not sensitive)
          host_firstname: row.meeting_type === 'Two-on-One' ? cleanedRow.host_firstname : (hasTwoOnOneNotesAccess ? cleanedRow.host_firstname : 'Restricted'),
          host_lastname: row.meeting_type === 'Two-on-One' ? cleanedRow.host_lastname : (hasTwoOnOneNotesAccess ? cleanedRow.host_lastname : 'Restricted'),
          host_chapter: row.meeting_type === 'Two-on-One' ? cleanedRow.host_chapter : (hasTwoOnOneNotesAccess ? cleanedRow.host_chapter : 'Restricted'),
          hasFullAccess: false,
          hasTwoOnOneNotesAccess
        };
      }
      
      return {
        ...cleanedRow,
        // Ensure Two-on-One fields are always included
        host_oneonone: cleanedRow.host_oneonone || false,
        host_vanid: cleanedRow.host_vanid || null,
        host_email: cleanedRow.host_email || null,
        two_risks: cleanedRow.two_risks || null,
        two_effective: cleanedRow.two_effective || null,
        two_support: cleanedRow.two_support || null,
        host_firstname: cleanedRow.host_firstname || null,
        host_lastname: cleanedRow.host_lastname || null,
        host_chapter: cleanedRow.host_chapter || null,
        hasFullAccess: true,
        hasTwoOnOneNotesAccess: true
      };
    });
    
    if (cleanedRows.length > 0) {
      // console.log('Sample accessible meeting:', {
      //   organizer: cleanedRows[0].organizer_firstname + ' ' + cleanedRows[0].organizer_lastname,
      //   contact: cleanedRows[0].contact_firstname + ' ' + cleanedRows[0].contact_lastname,
      //   date: cleanedRows[0].datestamp
      // });
      
      // Debug Two-on-One meeting final output
      const twoOnOneOutput = cleanedRows.find(row => row.meeting_type === 'Two-on-One');
      if (twoOnOneOutput) {
        // console.log('Two-on-One meeting final output to frontend:');
        // console.log({
        //   meeting_type: twoOnOneOutput.meeting_type,
        //   organizer: twoOnOneOutput.organizer,
        //   host_vanid: twoOnOneOutput.host_vanid,
        //   host_firstname: twoOnOneOutput.host_firstname,
        //   host_lastname: twoOnOneOutput.host_lastname,
        //   hasFullAccess: twoOnOneOutput.hasFullAccess,
        //   hasTwoOnOneNotesAccess: twoOnOneOutput.hasTwoOnOneNotesAccess
        // });
        }
      }
    
    // console.log(`\n=== FINAL RESULT ===`);
    // console.log(`Sending ${cleanedRows.length} conversations to frontend`);
    // if (cleanedRows.length > 0) {
    //   console.log('Sample final data being sent:');
    //   console.log(JSON.stringify(cleanedRows.slice(0, 2), null, 2));
    // }
    // console.log(`===================\n`);
    
    res.json(cleanedRows);
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ error: error.message });
  }
});

// New endpoint for histogram data aggregation (server-side)
app.get('/api/meetings/histogram', checkDataAccess, async (req, res) => {
  try {
    const { 
      granularity = 'week', // 'day', 'week', or 'month'
      scope = 'federation', // 'federation', 'chapter', 'person', or 'type'
      start_date,
      end_date,
      chapter,
      organizer,
      meeting_types // comma-separated list
    } = req.query;

    // Removed excessive logging - this endpoint is called very frequently
    // console.log(`ðŸ“Š /api/meetings/histogram called with: granularity=${granularity}, scope=${scope}, start_date=${start_date}, end_date=${end_date}, chapter=${chapter}, organizer=${organizer}, meeting_types=${meeting_types}`);

    // Build the time truncation expression based on granularity
    let timeExpression;
    let formatExpression;
    switch (granularity) {
      case 'day':
        timeExpression = 'DATE(c.date_contacted)';
        formatExpression = 'FORMAT_DATE("%b %d", DATE(c.date_contacted))';
        break;
      case 'month':
        timeExpression = 'DATE_TRUNC(DATE(c.date_contacted), MONTH)';
        formatExpression = 'FORMAT_DATE("%b %Y", DATE_TRUNC(DATE(c.date_contacted), MONTH))';
        break;
      case 'week':
      default:
        timeExpression = 'DATE_TRUNC(DATE(c.date_contacted), WEEK)';
        formatExpression = 'FORMAT_DATE("%b %d", DATE_TRUNC(DATE(c.date_contacted), WEEK))';
    }

    // Build the grouping expression based on scope
    let scopeExpression;
    let scopeLabel;
    switch (scope) {
      case 'chapter':
        scopeExpression = 'c.participant_chapter';
        scopeLabel = 'c.participant_chapter as scope_key';
        break;
      case 'person':
        scopeExpression = 'COALESCE(NULLIF(TRIM(CONCAT(COALESCE(o1.firstname, ""), " ", COALESCE(o1.lastname, ""))), ""), NULLIF(TRIM(CONCAT(COALESCE(cont2.first_name, ""), " ", COALESCE(cont2.last_name, ""))), ""), "Unknown")';
        scopeLabel = `${scopeExpression} as scope_key`;
        break;
      case 'type':
        scopeExpression = 'c.conversation_type';
        scopeLabel = 'c.conversation_type as scope_key';
        break;
      case 'federation':
      default:
        scopeExpression = '"Carolina Federation"';
        scopeLabel = '"Carolina Federation" as scope_key';
    }

    // Build WHERE clauses
    const whereClauses = ['1=1'];
    
    if (start_date) {
      whereClauses.push(`DATE(c.date_contacted) >= DATE('${start_date}')`);
    }
    if (end_date) {
      whereClauses.push(`DATE(c.date_contacted) <= DATE('${end_date}')`);
    }
    if (chapter && chapter !== 'All Chapters') {
      whereClauses.push(`c.participant_chapter = '${chapter}'`);
    }
    if (organizer) {
      whereClauses.push(`(
        LOWER(CONCAT(COALESCE(o1.firstname, ''), ' ', COALESCE(o1.lastname, ''))) LIKE LOWER('%${organizer}%')
        OR LOWER(CONCAT(COALESCE(cont2.first_name, ''), ' ', COALESCE(cont2.last_name, ''))) LIKE LOWER('%${organizer}%')
      )`);
    }
    if (meeting_types) {
      const types = meeting_types.split(',').map(t => `'${t.trim()}'`).join(',');
      whereClauses.push(`c.conversation_type IN (${types})`);
    }

    const query = `
      SELECT 
        ${timeExpression} as time_bucket,
        ${formatExpression} as time_label,
        ${scopeLabel},
        COUNT(*) as meeting_count
      FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` c
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o1
        ON CAST(c.organizer_vanid AS STRING) = CAST(o1.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont2 
        ON CAST(c.organizer_vanid AS STRING) = CAST(cont2.vanid AS STRING)
      WHERE ${whereClauses.join(' AND ')}
      GROUP BY time_bucket, time_label, scope_key
      ORDER BY time_bucket ASC
    `;

    // Removed excessive logging - this logs huge SQL queries frequently
    // console.log('ðŸ“Š Executing histogram query:', query);

    const [rows] = await bigquery.query({ query });
    
    console.log(`ðŸ“Š Histogram query returned ${rows.length} rows`);

    res.json({
      success: true,
      data: rows,
      params: { granularity, scope, start_date, end_date, chapter, organizer, meeting_types }
    });
  } catch (error) {
    console.error('âŒ Error in /api/meetings/histogram:', error);
    res.status(500).json({ 
      error: 'Failed to fetch histogram data', 
      details: error.message 
    });
  }
});

// Get meetings for specific contact IDs (basic data only - efficient for people panel)
app.post('/api/meetings/by-contacts', checkDataAccess, async (req, res) => {
  try {
    const { contact_ids, include_notes = false } = req.body;
    
    if (!contact_ids || !Array.isArray(contact_ids) || contact_ids.length === 0) {
      return res.status(400).json({ error: 'contact_ids array is required' });
    }
    
    // Removed excessive logging - this endpoint is called very frequently
    // console.log(`[/api/meetings/by-contacts] Fetching meetings for ${contact_ids.length} contacts, include_notes: ${include_notes}`);
    
    // Build the query - select only needed fields for efficiency
    const selectFields = include_notes 
      ? `conv.*, 
         org_contact.first_name as organizer_first_name, 
         org_contact.last_name as organizer_last_name`
      : `conv.participant_vanid,
         conv.organizer_vanid,
         conv.date_contacted,
         conv.conversation_type as meeting_type,
         org_contact.first_name as organizer_first_name,
         org_contact.last_name as organizer_last_name,
         conv.purpose as notes_purpose`;  // Only include latest note preview
    
    const query = `
      SELECT ${selectFields}
      FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` conv
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` org_contact 
        ON CAST(conv.organizer_vanid AS STRING) = CAST(org_contact.vanid AS STRING)
      WHERE CAST(conv.participant_vanid AS STRING) IN UNNEST(@contact_ids)
      ORDER BY conv.date_contacted DESC
    `;
    
    const [rows] = await bigquery.query({
      query,
      location: 'US',
      params: {
        contact_ids: contact_ids.map(id => String(id))
      }
    });
    
    // Removed excessive logging - this endpoint is called very frequently
    // console.log(`[/api/meetings/by-contacts] Found ${rows.length} meetings`);
    
    res.json(rows);
  } catch (error) {
    console.error('Error fetching meetings by contacts:', error);
    res.status(500).json({ error: error.message });
  }
});

// Backward compatibility alias for /api/meetings -> /api/conversations
app.get('/api/meetings', checkDataAccess, async (req, res) => {
  try {
    const { startDate, endDate, chapter, participant, page = 0, limit = 50000 } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    
    // console.log(`/api/meetings (alias) called with: startDate=${startDate}, endDate=${endDate}, chapter=${chapter}, participant=${participant}, limit=${limitNum}`);
    
    // Use the same logic as /api/conversations
    // NOTE: Names come from org_ids first, then contacts table as fallback (NOT from conversations)
    let query = `
      WITH ConversationsData AS (
        SELECT 
          c.organizer_vanid,
          -- Organizer name: try org_ids first, then contacts, then 'Unknown Organizer'
          COALESCE(
            NULLIF(TRIM(CONCAT(COALESCE(o1.firstname, ''), ' ', COALESCE(o1.lastname, ''))), ''),
            NULLIF(TRIM(CONCAT(COALESCE(cont2.first_name, ''), ' ', COALESCE(cont2.last_name, ''))), ''),
            'Unknown Organizer'
          ) as organizer,
          c.participant_vanid as vanid,
          c.date_contacted as datestamp,
          c.participant_chapter as chapter,
          c.conversation_type as meeting_type,
          c.purpose as notes_purpose,
          c.commitments as notes_commitments,
          c.stakes as notes_stakes,
          '' as notes_development,
          c.evaluation as notes_evaluation,
          -- Two-on-One meeting fields - host name: try org_ids first, then contacts
          CASE WHEN c.host_vanid IS NOT NULL THEN 
            COALESCE(
              NULLIF(TRIM(CONCAT(COALESCE(o3.firstname, ''), ' ', COALESCE(o3.lastname, ''))), ''),
              NULLIF(TRIM(CONCAT(COALESCE(cont3.first_name, ''), ' ', COALESCE(cont3.last_name, ''))), ''),
              'Unknown Host'
            )
          ELSE NULL END as host_oneonone,
          c.host_vanid,
          c.host_email,
          '' as two_risks,
          '' as two_effective,
          '' as two_support,
          -- Contact information (participant) - use contacts table for participant info
          COALESCE(cont1.first_name, c.participant_first_name) as contact_firstname,
          COALESCE(cont1.last_name, c.participant_last_name) as contact_lastname,
          c.participant_chapter as contact_chapter,
          cont1.loe as contact_loe,
          cont1.member_status as member_status,
          cont1.email as email,
          -- Organizer information - try org_ids first, then contacts
          COALESCE(o1.firstname, cont2.first_name) as organizer_firstname,
          COALESCE(o1.lastname, cont2.last_name) as organizer_lastname,
          cont2.chapter as organizer_chapter,
          cont2.loe as organizer_loe,
          -- Host information (for Two-on-One meetings) - try org_ids first, then contacts
          COALESCE(o3.firstname, cont3.first_name) as host_firstname,
          COALESCE(o3.lastname, cont3.last_name) as host_lastname,
          cont3.chapter as host_chapter,
          cont3.loe as host_loe,
          o1.userid as organizer_userid,
          o2.userid as contact_userid,
          o3.userid as host_userid
        FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` c
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont1 
          ON CAST(c.participant_vanid AS STRING) = CAST(cont1.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont2 
          ON CAST(c.organizer_vanid AS STRING) = CAST(cont2.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont3 
          ON CAST(c.host_vanid AS STRING) = CAST(cont3.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o1
          ON CAST(c.organizer_vanid AS STRING) = CAST(o1.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o2
          ON CAST(c.participant_vanid AS STRING) = CAST(o2.vanid AS STRING)
        LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o3
          ON CAST(c.host_vanid AS STRING) = CAST(o3.vanid AS STRING)
        WHERE 1=1
`;

    if (startDate) {
      query += ` AND DATE(c.date_contacted) >= DATE('${startDate}')`;
    }
    if (endDate) {
      query += ` AND DATE(c.date_contacted) <= DATE('${endDate}')`;
    }
    if (chapter && chapter !== 'All Chapters') {
      query += ` AND (c.participant_chapter = '${chapter}' OR cont2.chapter = '${chapter}')`;
    }
    if (participant) {
      // Filter by specific participant VAN ID - cast to STRING for comparison
      query += ` AND CAST(c.participant_vanid AS STRING) = '${participant}'`;
    }

    query += `)
      SELECT * FROM ConversationsData
      ORDER BY datestamp DESC
      LIMIT ${limitNum} OFFSET ${pageNum * limitNum}
    `;

    const [rows] = await bigquery.query({ query, location: 'US' });
    
    const filteredRows = rows.filter(row => {
      const organizerUserId = row.organizer_userid?.toString();
      const contactUserId = row.contact_userid?.toString();
      const hostUserId = row.host_userid?.toString();
      
      return req.accessibleIds.has(organizerUserId) || 
             req.accessibleIds.has(contactUserId) || 
             req.accessibleIds.has(hostUserId);
    });

    res.json(filteredRows);
  } catch (error) {
    // console.error('Error in meetings alias endpoint:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get meetings endpoint
app.get('/api/user-map-schema', async (req, res) => {
  try {
    // console.log('Checking user_map table schema...');
    
    const schemaQuery = `
      SELECT column_name, data_type
      FROM \`${PROJECT_ID}\`.${DATASET_ID}.INFORMATION_SCHEMA.COLUMNS
      WHERE table_name = 'user_map'
      ORDER BY ordinal_position
    `;
    
    const [columns] = await bigquery.query({ query: schemaQuery, location: 'US' });
    // console.log('User_map columns:', columns.map(col => col.column_name).join(', '));
    
    // Also get a sample row
    const sampleQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.user_map\`
      LIMIT 5
    `;
    
    const [rows] = await bigquery.query({ query: sampleQuery, location: 'US' });
    
    res.json({
      columns: columns,
      sampleData: rows
    });
  } catch (error) {
    console.error('Error checking user_map schema:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add a new endpoint to debug links between two specific nodes
app.get('/api/link-debug/:nodeId1/:nodeId2', async (req, res) => {
  try {
    const { nodeId1, nodeId2 } = req.params;
    // console.log(`Fetching debug data for link between nodes: ${nodeId1} and ${nodeId2}`);
    
    // Query contact_history for any interactions between these two nodes
    const contactHistoryQuery = `
      SELECT 
        ch.userid,
        ch.vanid,
        ch.username,
        ch.utc_datecanvassed,
        ch.contact_type,
        ch.contact_result,
        ch.input_source,
        c.firstname as target_first_name,
        c.lastname as target_last_name,
        c.chapter as target_chapter,
        c.loe as target_loe,
        um.firstname as organizer_first_name,
        um.lastname as organizer_last_name
      FROM 
        \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
      ON
        ch.vanid = c.vanid
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.user_map\` um
      ON
        ch.userid = um.userid
      WHERE 
        ((ch.userid = '${nodeId1}' OR CAST(ch.userid AS STRING) = '${nodeId1}') AND (ch.vanid = '${nodeId2}' OR CAST(ch.vanid AS STRING) = '${nodeId2}'))
        OR
        ((ch.userid = '${nodeId2}' OR CAST(ch.userid AS STRING) = '${nodeId2}') AND (ch.vanid = '${nodeId1}' OR CAST(ch.vanid AS STRING) = '${nodeId1}'))
      ORDER BY ch.utc_datecanvassed DESC
    `;

    // Query conversations for any interactions between these two nodes
    // NOTE: Names come from org_ids first, then contacts table as fallback (NOT from conversations)
    const conversationsQuery = `
      SELECT 
        c.organizer_vanid,
        c.participant_vanid as vanid,
        c.date_contacted as datestamp,
        c.participant_chapter as chapter,
        c.conversation_type as meeting_type,
        c.purpose as notes_purpose,
        c.commitments as notes_commitments,
        c.stakes as notes_stakes,
        '' as notes_development,
        c.evaluation as notes_evaluation,
        -- Contact information (participant) - use contacts table
        COALESCE(cont1.first_name, c.participant_first_name) as contact_firstname,
        COALESCE(cont1.last_name, c.participant_last_name) as contact_lastname,
        c.participant_chapter as contact_chapter,
        cont1.loe as contact_loe,
        -- Organizer information - try org_ids first, then contacts
        COALESCE(o1.firstname, cont2.first_name) as organizer_firstname,
        COALESCE(o1.lastname, cont2.last_name) as organizer_lastname,
        cont2.chapter as organizer_chapter,
        cont2.loe as organizer_loe
      FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` c
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont1 
        ON CAST(c.participant_vanid AS STRING) = CAST(cont1.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont2 
        ON CAST(c.organizer_vanid AS STRING) = CAST(cont2.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o1
        ON CAST(c.organizer_vanid AS STRING) = CAST(o1.vanid AS STRING)
      WHERE 
        ((c.organizer_vanid = '${nodeId1}' OR CAST(c.organizer_vanid AS STRING) = '${nodeId1}') AND (c.participant_vanid = '${nodeId2}' OR CAST(c.participant_vanid AS STRING) = '${nodeId2}'))
        OR
        ((c.organizer_vanid = '${nodeId2}' OR CAST(c.organizer_vanid AS STRING) = '${nodeId2}') AND (c.participant_vanid = '${nodeId1}' OR CAST(c.participant_vanid AS STRING) = '${nodeId1}'))
      ORDER BY c.date_contacted DESC
    `;

    // Execute queries in parallel
    const [contactHistoryRows] = await bigquery.query({ query: contactHistoryQuery, location: 'US' });
    const [conversationsRows] = await bigquery.query({ query: conversationsQuery, location: 'US' });

    // console.log(`Link debug data between ${nodeId1} and ${nodeId2}:`);
    // console.log(`- Contact History: ${contactHistoryRows.length} rows`);
    // console.log(`- Conversations: ${conversationsRows.length} rows`);

    // Log detailed results
    if (contactHistoryRows.length > 0) {
      // console.log('Contact History Details:');
      contactHistoryRows.forEach((row, idx) => {
        // console.log(`  ${idx + 1}. User ${row.userid} (${row.organizer_first_name} ${row.organizer_last_name}) contacted VAN ${row.vanid} (${row.target_first_name} ${row.target_last_name}) on ${row.utc_datecanvassed}`);
      });
    }

    if (conversationsRows.length > 0) {
      // console.log('Conversations Details:');
      conversationsRows.forEach((row, idx) => {
        // console.log(`  ${idx + 1}. Organizer VAN ${row.organizer_vanid} (${row.organizer_firstname} ${row.organizer_lastname}) met with VAN ${row.vanid} (${row.contact_firstname} ${row.contact_lastname}) on ${row.datestamp}`);
      });
    }

    res.json({
      nodeId1,
      nodeId2,
      contactHistory: contactHistoryRows,
      meetings: conversationsRows,
      summary: {
        contactHistoryCount: contactHistoryRows.length,
        meetingsCount: conversationsRows.length
      }
    });
  } catch (error) {
    // console.error(`Error fetching link debug data between ${req.params.nodeId1} and ${req.params.nodeId2}:`, error);
    res.status(500).json({ error: error.message });
  }
});

// Add a new endpoint to get raw meeting/contact data for a specific node for debugging
app.get('/api/node-debug/:nodeId', async (req, res) => {
  try {
    const { nodeId } = req.params;
    // console.log(`Fetching debug data for node: ${nodeId}`);
    
    // Query contact_history for this node as both source and target
    const contactHistoryQuery = `
      SELECT 
        ch.userid,
        ch.vanid,
        ch.username,
        ch.utc_datecanvassed,
        ch.contact_type,
        ch.contact_result,
        ch.input_source,
        c.firstname as target_first_name,
        c.lastname as target_last_name,
        c.chapter as target_chapter,
        c.loe as target_loe,
        um.firstname as organizer_first_name,
        um.lastname as organizer_last_name
      FROM 
        \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
      ON
        ch.vanid = c.vanid
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.user_map\` um
      ON
        ch.userid = um.userid
      WHERE 
        ch.userid = '${nodeId}' OR ch.vanid = '${nodeId}'
        OR CAST(ch.userid AS STRING) = '${nodeId}' OR CAST(ch.vanid AS STRING) = '${nodeId}'
      ORDER BY ch.utc_datecanvassed DESC
      LIMIT 100
    `;

    // Query conversations for this node as both organizer and participant
    // NOTE: Names come from org_ids first, then contacts table as fallback (NOT from conversations)
    const conversationsQuery = `
      SELECT 
        c.organizer_vanid,
        c.participant_vanid as vanid,
        c.date_contacted as datestamp,
        c.participant_chapter as chapter,
        c.conversation_type as meeting_type,
        c.purpose as notes_purpose,
        c.commitments as notes_commitments,
        c.stakes as notes_stakes,
        '' as notes_development,
        c.evaluation as notes_evaluation,
        -- Contact information (participant) - use contacts table
        COALESCE(cont1.first_name, c.participant_first_name) as contact_firstname,
        COALESCE(cont1.last_name, c.participant_last_name) as contact_lastname,
        c.participant_chapter as contact_chapter,
        cont1.loe as contact_loe,
        -- Organizer information - try org_ids first, then contacts
        COALESCE(o1.firstname, cont2.first_name) as organizer_firstname,
        COALESCE(o1.lastname, cont2.last_name) as organizer_lastname,
        cont2.chapter as organizer_chapter,
        cont2.loe as organizer_loe
      FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` c
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont1 
        ON CAST(c.participant_vanid AS STRING) = CAST(cont1.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont2 
        ON CAST(c.organizer_vanid AS STRING) = CAST(cont2.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o1
        ON CAST(c.organizer_vanid AS STRING) = CAST(o1.vanid AS STRING)
      WHERE 
        c.organizer_vanid = '${nodeId}' OR c.participant_vanid = '${nodeId}'
        OR CAST(c.organizer_vanid AS STRING) = '${nodeId}' OR CAST(c.participant_vanid AS STRING) = '${nodeId}'
      ORDER BY c.date_contacted DESC
      LIMIT 100
    `;

    // Query org_ids to get additional info about this node
    const orgIdsQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      WHERE 
        vanid = '${nodeId}' OR userid = '${nodeId}'
        OR CAST(vanid AS STRING) = '${nodeId}' OR CAST(userid AS STRING) = '${nodeId}'
    `;

    // Query contacts table
    const contactsQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.contacts\`
      WHERE 
        vanid = '${nodeId}' OR CAST(vanid AS STRING) = '${nodeId}'
    `;

    // Execute all queries in parallel
    const [contactHistoryRows] = await bigquery.query({ query: contactHistoryQuery, location: 'US' });
    const [conversationsRows] = await bigquery.query({ query: conversationsQuery, location: 'US' });
    const [orgIdsRows] = await bigquery.query({ query: orgIdsQuery, location: 'US' });
    const [contactsRows] = await bigquery.query({ query: contactsQuery, location: 'US' });

    // console.log(`Debug data for node ${nodeId}:`);
    // console.log(`- Contact History: ${contactHistoryRows.length} rows`);
    // console.log(`- Conversations: ${conversationsRows.length} rows`);
    // console.log(`- Org IDs: ${orgIdsRows.length} rows`);
    // console.log(`- Contacts: ${contactsRows.length} rows`);

    // Return all the raw data
    res.json({
      nodeId,
      contactHistory: contactHistoryRows,
      meetings: conversationsRows,
      orgIds: orgIdsRows,
      contacts: contactsRows,
      summary: {
        contactHistoryCount: contactHistoryRows.length,
        meetingsCount: conversationsRows.length,
        orgIdsCount: orgIdsRows.length,
        contactsCount: contactsRows.length
      }
    });
  } catch (error) {
    // console.error(`Error fetching debug data for node ${req.params.nodeId}:`, error);
    res.status(500).json({ error: error.message });
  }
});

// Add endpoint to get comprehensive network data including Two-on-One meeting hosts
app.get('/api/network-data-with-hosts', checkDataAccess, async (req, res) => {
  try {
    const { start_date, end_date, chapter, page = 0, limit = 1000 } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    // console.log('Network data with hosts request:', { start_date, end_date, chapter, page, limit });

    // Query contact history data directly
    let contactHistoryQuery = `
      SELECT 
        ch.userid,
        ch.vanid,
        ch.username,
        ch.utc_datecanvassed,
        ch.contact_type,
        ch.contact_result,
        ch.input_source,
        c.firstname as target_first_name,
        c.lastname as target_last_name,
        c.chapter as target_chapter,
        um.firstname as organizer_first_name,
        um.lastname as organizer_last_name
      FROM 
        \`${PROJECT_ID}.${DATASET_ID}.contact_history\` ch
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
      ON
        ch.vanid = c.vanid
      LEFT JOIN
        \`${PROJECT_ID}.${DATASET_ID}.user_map\` um
      ON
        ch.userid = um.userid
      WHERE 1=1
    `;

    // Add date filters for contact history
    if (start_date) {
      contactHistoryQuery += ` AND ch.utc_datecanvassed >= TIMESTAMP('${start_date}')`;
    }
    if (end_date) {
      contactHistoryQuery += ` AND ch.utc_datecanvassed <= TIMESTAMP('${end_date}')`;
    }
    if (chapter && chapter !== 'All Chapters') {
      contactHistoryQuery += ` AND c.chapter = '${chapter}'`;
    }
    contactHistoryQuery += ` ORDER BY ch.utc_datecanvassed DESC LIMIT ${limitNum} OFFSET ${pageNum * limitNum}`;

    // Query conversations data with Two-on-One information
    // NOTE: Names come from org_ids first, then contacts table as fallback (NOT from conversations)
    let conversationsQuery = `
      SELECT 
        c.organizer_vanid,
        c.participant_vanid as vanid,
        c.date_contacted as datestamp,
        c.participant_chapter as chapter,
        c.conversation_type as meeting_type,
        c.purpose as notes_purpose,
        c.commitments as notes_commitments,
        c.stakes as notes_stakes,
        '' as notes_development,
        c.evaluation as notes_evaluation,
        -- Two-on-One meeting fields - host name: try org_ids first, then contacts
        CASE WHEN c.host_vanid IS NOT NULL THEN 
          COALESCE(
            NULLIF(TRIM(CONCAT(COALESCE(o3.firstname, ''), ' ', COALESCE(o3.lastname, ''))), ''),
            NULLIF(TRIM(CONCAT(COALESCE(cont3.first_name, ''), ' ', COALESCE(cont3.last_name, ''))), ''),
            'Unknown Host'
          )
        ELSE NULL END as host_oneonone,
        c.host_vanid,
        c.host_email,
        '' as two_risks,
        '' as two_effective,
        '' as two_support,
        -- Contact information (participant) - use contacts table
        COALESCE(cont1.first_name, c.participant_first_name) as contact_firstname,
        COALESCE(cont1.last_name, c.participant_last_name) as contact_lastname,
        c.participant_chapter as contact_chapter,
        -- Organizer information - try org_ids first, then contacts
        COALESCE(o1.firstname, cont2.first_name) as organizer_firstname,
        COALESCE(o1.lastname, cont2.last_name) as organizer_lastname,
        cont2.chapter as organizer_chapter,
        -- Host information (for Two-on-One meetings) - try org_ids first, then contacts
        COALESCE(o3.firstname, cont3.first_name) as host_firstname,
        COALESCE(o3.lastname, cont3.last_name) as host_lastname,
        cont3.chapter as host_chapter,
        o1.userid as organizer_userid,
        o2.userid as contact_userid,
        o3.userid as host_userid
      FROM \`${PROJECT_ID}.${DATASET_ID}.conversations\` c
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont1 
        ON CAST(c.participant_vanid AS STRING) = CAST(cont1.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont2 
        ON CAST(c.organizer_vanid AS STRING) = CAST(cont2.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` cont3 
        ON CAST(c.host_vanid AS STRING) = CAST(cont3.vanid AS STRING)
      
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o1
        ON CAST(c.organizer_vanid AS STRING) = CAST(o1.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o2
        ON CAST(c.participant_vanid AS STRING) = CAST(o2.vanid AS STRING)
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.org_ids\` o3
        ON CAST(c.host_vanid AS STRING) = CAST(o3.vanid AS STRING)
      WHERE 1=1
    `;

    // Add date filters for conversations
    if (start_date) {
      conversationsQuery += ` AND DATE(c.date_contacted) >= DATE('${start_date}')`;
    }
    if (end_date) {
      conversationsQuery += ` AND DATE(c.date_contacted) <= DATE('${end_date}')`;
    }
    if (chapter && chapter !== 'All Chapters') {
      // Include conversations where EITHER the participant OR organizer is from the selected chapter
      conversationsQuery += ` AND (c.participant_chapter = '${chapter}' OR cont2.chapter = '${chapter}')`;
    }
    conversationsQuery += ` ORDER BY c.date_contacted DESC LIMIT ${limitNum} OFFSET ${pageNum * limitNum}`;

    // Execute both queries
    const [contactHistoryRows] = await bigquery.query({ query: contactHistoryQuery, location: 'US' });
    const [conversationsRows] = await bigquery.query({ query: conversationsQuery, location: 'US' });

    // console.log(`Retrieved ${contactHistoryRows.length} contact history rows and ${conversationsRows.length} conversation rows`);

    // Apply access control to contact history
    let processedContactHistory = contactHistoryRows.map(row => {
      const userid = row.userid?.toString();
      const vanid = row.vanid?.toString();
      
      const hasOrganizerAccess = req.accessibleIds.has(userid);
      const hasContactAccess = req.accessibleIds.has(vanid);
      const hasFullAccess = hasOrganizerAccess || hasContactAccess;
      
      return {
        ...row,
        hasFullAccess
      };
    });

    // Apply access control to meetings and create host connections
    let processedMeetings = [];
    let hostConnections = [];

    conversationsRows.forEach(row => {
      const organizerVanId = row.organizer_vanid?.toString();
      const contactVanId = row.vanid?.toString();
      const hostVanId = row.host_vanid?.toString();
      const organizerUserId = row.organizer_userid?.toString();
      const contactUserId = row.contact_userid?.toString();
      const hostUserId = row.host_userid?.toString();
      
      // Access control check for general meeting visibility
      const hasOrganizerAccess = req.accessibleIds.has(organizerVanId) || req.accessibleIds.has(organizerUserId);
      const hasContactAccess = req.accessibleIds.has(contactVanId) || req.accessibleIds.has(contactUserId);
      const hasHostAccess = hostVanId && (req.accessibleIds.has(hostVanId) || req.accessibleIds.has(hostUserId));
      const hasFullAccess = hasOrganizerAccess || hasContactAccess || hasHostAccess;

      // For Two-on-One meetings, Two-on-One notes access is based specifically on organizer access
      const hasTwoOnOneNotesAccess = row.meeting_type === 'Two-on-One' ? hasOrganizerAccess : hasFullAccess;

      // Add processed meeting
      processedMeetings.push({
        ...row,
        hasFullAccess,
        hasTwoOnOneNotesAccess
      });

             // Create host connection for Two-on-One meetings
       if (row.meeting_type === 'Two-on-One' && hostVanId && contactVanId) {
        hostConnections.push({
          userid: hostVanId,
          vanid: contactVanId,
          username: row.host_firstname && row.host_lastname 
            ? `${row.host_firstname} ${row.host_lastname}` 
            : `Host ${hostVanId}`,
          source_name: row.host_firstname && row.host_lastname 
            ? `${row.host_firstname} ${row.host_lastname}` 
            : `Host ${hostVanId}`,
          target_name: row.contact_firstname && row.contact_lastname
            ? `${row.contact_firstname} ${row.contact_lastname}`
            : `Contact ${contactVanId}`,
          source_chapter: row.host_chapter || 'Unknown',
          target_chapter: row.contact_chapter || 'Unknown',
          utc_datecanvassed: row.datestamp ? new Date(row.datestamp).toISOString() : new Date().toISOString(),
          contact_type: 'Two-on-One Meeting (Host)',
          contact_result: 'Meeting Completed',
          input_source: 'Two-on-One Meeting',
          hasFullAccess,
          meeting_type: 'host_connection'
        });
      }
    });

    // Format contact history data
    const formattedContactHistory = processedContactHistory.map(row => {
      const userid = row.userid ? row.userid.toString() : '';
      const vanid = row.vanid ? row.vanid.toString() : '';
      const hasFullAccess = row.hasFullAccess !== false;
      
      return {
        userid,
        vanid,
        username: hasFullAccess ? (row.username || '') : 'Restricted',
        source_name: hasFullAccess ? (row.username || `User ${userid}`) : 'Restricted User',
        target_name: hasFullAccess && row.target_first_name && row.target_last_name
          ? `${row.target_first_name} ${row.target_last_name}`
          : hasFullAccess ? `Contact ${vanid}` : 'Restricted Contact',
        source_chapter: hasFullAccess ? 'Unknown' : 'Restricted',
        target_chapter: hasFullAccess ? (row.target_chapter || 'Unknown') : 'Restricted',
        utc_datecanvassed: row.utc_datecanvassed ? row.utc_datecanvassed.value || row.utc_datecanvassed : new Date().toISOString(),
        contact_type: hasFullAccess ? (row.contact_type || 'Unknown') : 'Restricted',
        contact_result: hasFullAccess ? (row.contact_result || 'Unknown') : 'Restricted',
        input_source: hasFullAccess ? (row.input_source || 'Unknown') : 'Restricted',
        hasFullAccess
      };
    }).filter(row => row.userid && row.vanid);

    // Format meetings data
    const formattedMeetings = processedMeetings.map(row => {
      const hasFullAccess = row.hasFullAccess !== false;
      const hasTwoOnOneNotesAccess = row.hasTwoOnOneNotesAccess !== false;
      
      return {
        ...row,
        notes_purpose: hasFullAccess ? row.notes_purpose : 'Restricted - No Access',
        notes_commitments: hasFullAccess ? row.notes_commitments : 'Restricted - No Access',
        notes_stakes: hasFullAccess ? row.notes_stakes : 'Restricted - No Access',
        notes_development: hasFullAccess ? row.notes_development : 'Restricted - No Access',
        notes_evaluation: hasFullAccess ? row.notes_evaluation : 'Restricted - No Access',
        // Two-on-One notes access is based specifically on organizer access
        two_risks: hasTwoOnOneNotesAccess ? row.two_risks : 'Restricted - No Access',
        two_effective: hasTwoOnOneNotesAccess ? row.two_effective : 'Restricted - No Access',
        two_support: hasTwoOnOneNotesAccess ? row.two_support : 'Restricted - No Access'
      };
    });

    // Combine all network data
    const combinedNetworkData = [...formattedContactHistory, ...hostConnections];

    // console.log(`Returning comprehensive network data: ${combinedNetworkData.length} connections (${formattedContactHistory.length} contact history + ${hostConnections.length} host connections)`);
    
    res.json({
      networkData: combinedNetworkData,
      meetingsData: formattedMeetings,
      stats: {
        contactHistoryConnections: formattedContactHistory.length,
        hostConnections: hostConnections.length,
        totalConnections: combinedNetworkData.length,
                 twoOnOneMeetings: formattedMeetings.filter(m => m.meeting_type === 'Two-on-One').length,
        totalMeetings: formattedMeetings.length
      }
    });
  } catch (error) {
    // console.error('Error fetching network data with hosts:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add endpoint to test organizational access control
app.get('/api/org-access-test', checkDataAccess, async (req, res) => {
  try {
    const orgStructure = await getOrgStructure();
    
    if (!orgStructure) {
      return res.status(500).json({ error: 'Could not load organizational structure' });
    }
    
    // Get user info
    const userInfo = req.currentUserId ? orgStructure.userInfo.get(req.currentUserId) : null;
    
    // Get subordinates
    const subordinates = [];
    if (req.currentUserId && orgStructure.supervisorToUsers.has(req.currentUserId)) {
      const subordinateIds = orgStructure.supervisorToUsers.get(req.currentUserId);
      subordinateIds.forEach(id => {
        const info = orgStructure.userInfo.get(id);
        if (info) {
          subordinates.push(info);
        }
      });
    }
    
    // Get supervisor
    const supervisorId = req.currentUserId ? orgStructure.userToSupervisor.get(req.currentUserId) : null;
    const supervisor = supervisorId ? orgStructure.userInfo.get(supervisorId) : null;
    
    res.json({
      currentUser: {
        id: req.currentUserId,
        hasAccess: req.hasDataAccess,
        accessibleIds: Array.from(req.accessibleIds).slice(0, 20), // Show first 20 for brevity
        totalAccessibleIds: req.accessibleIds.size,
        userInfo
      },
      hierarchy: {
        supervisor,
        subordinates,
        subordinateCount: subordinates.length
      },
      orgStats: {
        totalUsers: orgStructure.userInfo.size,
        totalSupervisors: orgStructure.supervisorToUsers.size
      }
    });
  } catch (error) {
    console.error('Error in org access test:', error);
    res.status(500).json({ error: error.message });
  }
});

// Debug endpoint to test pledge access
app.get('/api/pledge-access-test', async (req, res) => {
  try {
    const testQuery = `
      SELECT COUNT(*) as count
      FROM \`${PROJECT_ID}.pledge_campaign.pledge_submissions\`
      LIMIT 1
    `;
    
    console.log('Testing pledge access with query:', testQuery);
    
    const [rows] = await bigquery.query({ query: testQuery, location: 'US' });
    
    res.json({
      success: true,
      message: 'Server has access to pledge_campaign.pledge_submissions',
      count: rows[0]?.count || 0,
      tableReference: `${PROJECT_ID}.pledge_campaign.pledge_submissions`
    });
  } catch (error) {
    console.error('Pledge access test failed:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      tableReference: `${PROJECT_ID}.pledge_campaign.pledge_submissions`,
      hint: 'The service account may not have access to the pledge_campaign dataset. Ask admin to grant BigQuery Data Viewer role to the service account on the pledge_campaign dataset.',
      serviceAccountHint: 'Check which service account is configured in GOOGLE_APPLICATION_CREDENTIALS or the mounted credentials file'
    });
  }
});

// Get pledge submissions for campaign actuals
// Get pledge submissions for campaign actuals
app.get('/api/pledge-submissions', async (req, res) => {
  try {
    const { startDate, endDate, chapter } = req.query;
    const params = {};
    
    let query = `
      SELECT date_submitted, chapter, COUNT(*) as pledge_count,
        ARRAY_AGG(STRUCT(vanid, first_name, last_name, leader, desired_change)) as submissions
      FROM \`${PROJECT_ID}.pledge_campaign.pledge_submissions\`
      WHERE date_submitted IS NOT NULL`;
    
    if (startDate) { query += ` AND date_submitted >= @startDate`; params.startDate = startDate; }
    if (endDate) { query += ` AND date_submitted <= @endDate`; params.endDate = endDate; }
    if (chapter && chapter !== 'All Chapters') { query += ` AND chapter = @chapter`; params.chapter = chapter; }
    
    query += ` GROUP BY date_submitted, chapter ORDER BY date_submitted ASC`;
    
    const [rows] = await bigquery.query({ query, params });
    const totalPledges = rows.reduce((sum, row) => sum + (row.pledge_count || 0), 0);
    
    res.json({ success: true, data: rows, totalPledges, daysWithPledges: rows.length });
  } catch (error) {
    console.error('Error fetching pledge submissions:', error.message);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================================================
// DASHBOARD API ENDPOINTS - Lists, Leaders, Goals
// ============================================================================

// GET /api/actions - Fetch active actions (optionally filtered by organizer)
app.get('/api/actions', async (req, res) => {
  try {
    const { organizer_vanid, organizer_chapter } = req.query;
    console.log('[/api/actions] organizer_vanid:', organizer_vanid, 'organizer_chapter:', organizer_chapter);
    
    // Removed excessive logging - this endpoint is called very frequently
    // console.log(`[API /actions] Request for organizer_vanid: ${organizer_vanid}`);
    
    let query;
    let queryOptions;
    
    if (organizer_vanid) {
      // Filter to show only actions visible to this organizer
      // Include: 1) Actions they created, 2) Actions they're in visible_to_organizers, 3) Federation-wide actions (null/empty visible_to_organizers), 4) ALL templates (automatically available to everyone), 5) Chapter-specific actions
      query = `
        SELECT 
          action_id,
          action_name,
          goal_type,
          parent_campaign_id,
          description,
          fields,
          goal_field_key,
          is_active,
          organizer_vanid,
          visible_to_organizers,
          chapters,
          status,
          started_date,
          archived_date,
          has_goal,
          target_audience,
          is_template,
          template_action_id,
          default_individual_goal,
          action_type,
          recurrence_period,
          recurrence_count,
          deadline_date,
          deadline_type,
          time_tracking_enabled
        FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_actions\`
        WHERE is_active = TRUE
          AND (
            is_template = TRUE  -- All templates automatically available to everyone
            OR organizer_vanid = @organizer_vanid  -- Actions you created
            OR (
              -- Check both organizer visibility AND chapter visibility
              -- Organizer check: NULL/empty visible_to_organizers OR you're in the list
              (visible_to_organizers IS NULL OR ARRAY_LENGTH(visible_to_organizers) = 0 OR @organizer_vanid IN UNNEST(visible_to_organizers))
              AND
              -- Chapter check: NULL/empty chapters OR your chapter is in the list
              ${organizer_chapter 
                ? `(chapters IS NULL OR ARRAY_LENGTH(chapters) = 0 OR @organizer_chapter IN UNNEST(chapters))`
                : `(chapters IS NULL OR ARRAY_LENGTH(chapters) = 0)`
              }
            )
          )
        ORDER BY action_id
      `;
      queryOptions = {
        query,
        params: {
          organizer_vanid,
          ...(organizer_chapter && { organizer_chapter })
        }
      };
    } else {
      // Return all active actions
      query = `
        SELECT 
          action_id,
          action_name,
          goal_type,
          parent_campaign_id,
          description,
          fields,
          goal_field_key,
          is_active,
          organizer_vanid,
          visible_to_organizers,
          chapters,
          status,
          started_date,
          archived_date,
          has_goal,
          target_audience,
          is_template,
          template_action_id,
          default_individual_goal,
          action_type,
          recurrence_period,
          recurrence_count,
          deadline_date,
          deadline_type,
          time_tracking_enabled
        FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_actions\`
        WHERE is_active = TRUE
        ORDER BY action_id
      `;
      queryOptions = { query };
    }
    
    const [rows] = await bigquery.query(queryOptions);
    
    // Removed excessive logging - this endpoint is called very frequently
    // console.log(`[API /actions] Found ${rows.length} actions for organizer ${organizer_vanid}`);
    // if (rows.length > 0) {
    //   console.log('[API /actions] Sample action:', {
    //     action_id: rows[0].action_id,
    //     action_name: rows[0].action_name,
    //     organizer_vanid: rows[0].organizer_vanid,
    //     visible_to_organizers: rows[0].visible_to_organizers,
    //     status: rows[0].status
    //   });
    // }
    
    // Parse JSON fields
    const actions = rows.map(row => ({
      ...row,
      fields: typeof row.fields === 'string' ? JSON.parse(row.fields) : row.fields
    }));
    
    res.json(actions);
  } catch (error) {
    console.error('Error fetching actions:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/actions - Create a new action
app.post('/api/actions', async (req, res) => {
  try {
    const { 
      action_name, 
      fields,
      goal_field_key,
      parent_campaign_id, 
      goal_type_id, 
      chapters,
      organizer_vanid,
      visible_to_organizers,
      has_goal,
      target_audience,
      is_template,
      template_action_id,
      default_individual_goal,
      
      // NEW: Rate-based and deadline fields
      action_type,
      recurrence_period,
      recurrence_count,
      deadline_date,
      deadline_type,
      time_tracking_enabled
    } = req.body;
    
    if (!action_name || !fields || !Array.isArray(fields)) {
      return res.status(400).json({ 
        success: false, 
        error: 'action_name and fields are required' 
      });
    }
    
    // Generate action_id from name (lowercase, underscored)
    const action_id = action_name.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
    
    // Insert new action
    const query = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_actions\`
      (
        action_id, 
        action_name, 
        goal_type, 
        goal_field_key,
        parent_campaign_id,
        description, 
        fields, 
        is_active,
        organizer_vanid,
        visible_to_organizers,
        chapters,
        status,
        started_date,
        has_goal,
        target_audience,
        is_template,
        template_action_id,
        default_individual_goal,
        action_type,
        recurrence_period,
        recurrence_count,
        deadline_date,
        deadline_type,
        time_tracking_enabled
      )
      VALUES (
        @action_id,
        @action_name,
        ${goal_type_id ? '@goal_type' : 'CAST(NULL AS STRING)'},
        ${goal_field_key ? '@goal_field_key' : 'CAST(NULL AS STRING)'},
        ${parent_campaign_id ? '@parent_campaign_id' : 'CAST(NULL AS STRING)'},
        @description,
        PARSE_JSON(@fields),
        TRUE,
        ${organizer_vanid ? '@organizer_vanid' : 'CAST(NULL AS STRING)'},
        ${visible_to_organizers && visible_to_organizers.length > 0 ? '@visible_to_organizers' : 'CAST(NULL AS ARRAY<STRING>)'},
        ${chapters && chapters.length > 0 ? '@chapters' : 'CAST(NULL AS ARRAY<STRING>)'},
        'live',
        CURRENT_DATE(),
        ${has_goal !== undefined ? '@has_goal' : 'TRUE'},
        ${target_audience ? '@target_audience' : "'constituent'"},
        ${is_template !== undefined ? '@is_template' : 'FALSE'},
        ${template_action_id ? '@template_action_id' : 'CAST(NULL AS STRING)'},
        ${default_individual_goal !== undefined ? '@default_individual_goal' : '5'},
        ${action_type ? '@action_type' : "'one_time'"},
        ${recurrence_period ? '@recurrence_period' : 'CAST(NULL AS STRING)'},
        ${recurrence_count !== undefined ? '@recurrence_count' : 'CAST(NULL AS INT64)'},
        ${deadline_date ? '@deadline_date' : 'CAST(NULL AS DATE)'},
        ${deadline_type ? '@deadline_type' : "'soft'"},
        ${time_tracking_enabled !== undefined ? '@time_tracking_enabled' : 'FALSE'}
      )
    `;
    
    const params = {
      action_id,
      action_name,
      description: '', // Can be added later if needed
      fields: JSON.stringify(fields) // Must be a JSON string for PARSE_JSON
    };
    
    // Only add params that are not null
    if (goal_type_id) params.goal_type = goal_type_id;
    if (goal_field_key) params.goal_field_key = goal_field_key;
    if (parent_campaign_id) params.parent_campaign_id = parent_campaign_id;
    if (organizer_vanid) params.organizer_vanid = organizer_vanid;
    if (action_type) params.action_type = action_type;
    if (recurrence_period) params.recurrence_period = recurrence_period;
    if (recurrence_count !== undefined) params.recurrence_count = recurrence_count;
    if (deadline_date) params.deadline_date = deadline_date;
    if (deadline_type) params.deadline_type = deadline_type;
    if (time_tracking_enabled !== undefined) params.time_tracking_enabled = time_tracking_enabled;
    if (visible_to_organizers && visible_to_organizers.length > 0) {
      params.visible_to_organizers = visible_to_organizers;
    }
    if (is_template !== undefined) params.is_template = is_template;
    if (template_action_id) params.template_action_id = template_action_id;
    if (chapters && chapters.length > 0) {
      params.chapters = chapters;
    }
    if (has_goal !== undefined) params.has_goal = has_goal;
    if (target_audience) params.target_audience = target_audience;
    if (default_individual_goal !== undefined) params.default_individual_goal = default_individual_goal;
    
    await bigquery.query({ query, params });
    
    res.json({ 
      success: true, 
      message: 'Action created successfully',
      action_id 
    });
  } catch (error) {
    console.error('Error creating action:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/actions/:action_id - Update an action
app.put('/api/actions/:action_id', async (req, res) => {
  try {
    const { action_id } = req.params;
    const { 
      action_name, 
      fields,
      goal_field_key,
      parent_campaign_id, 
      goal_type_id, 
      chapters,
      organizer_vanid,
      visible_to_organizers,
      has_goal,
      target_audience,
      is_template,
      template_action_id,
      default_individual_goal,
      
      // NEW: Rate-based and deadline fields
      action_type,
      recurrence_period,
      recurrence_count,
      deadline_date,
      deadline_type,
      time_tracking_enabled
    } = req.body;
    
    if (!action_id || !action_name || !fields || !Array.isArray(fields)) {
      return res.status(400).json({ 
        success: false, 
        error: 'action_id, action_name, and fields are required' 
      });
    }
    
    // Update action
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_actions\`
      SET 
        action_name = @action_name,
        goal_type = ${goal_type_id ? '@goal_type' : 'NULL'},
        goal_field_key = ${goal_field_key ? '@goal_field_key' : 'NULL'},
        parent_campaign_id = ${parent_campaign_id ? '@parent_campaign_id' : 'NULL'},
        fields = PARSE_JSON(@fields),
        organizer_vanid = ${organizer_vanid ? '@organizer_vanid' : 'NULL'},
        visible_to_organizers = ${visible_to_organizers && visible_to_organizers.length > 0 ? '@visible_to_organizers' : 'NULL'},
        chapters = ${chapters && chapters.length > 0 ? '@chapters' : 'CAST(NULL AS ARRAY<STRING>)'},
        has_goal = ${has_goal !== undefined ? '@has_goal' : 'TRUE'},
        target_audience = ${target_audience ? '@target_audience' : "'constituent'"},
        is_template = ${is_template !== undefined ? '@is_template' : 'FALSE'},
        template_action_id = ${template_action_id ? '@template_action_id' : 'NULL'},
        default_individual_goal = ${default_individual_goal !== undefined ? '@default_individual_goal' : '5'},
        action_type = ${action_type ? '@action_type' : "'one_time'"},
        recurrence_period = ${recurrence_period ? '@recurrence_period' : 'NULL'},
        recurrence_count = ${recurrence_count !== undefined ? '@recurrence_count' : 'NULL'},
        deadline_date = ${deadline_date ? '@deadline_date' : 'NULL'},
        deadline_type = ${deadline_type ? '@deadline_type' : "'soft'"},
        time_tracking_enabled = ${time_tracking_enabled !== undefined ? '@time_tracking_enabled' : 'FALSE'}
      WHERE action_id = @action_id
    `;
    
    const params = {
      action_id,
      action_name,
      fields: JSON.stringify(fields)
    };
    
    if (goal_type_id) params.goal_type = goal_type_id;
    if (goal_field_key) params.goal_field_key = goal_field_key;
    if (parent_campaign_id) params.parent_campaign_id = parent_campaign_id;
    if (organizer_vanid) params.organizer_vanid = organizer_vanid;
    if (action_type) params.action_type = action_type;
    if (recurrence_period) params.recurrence_period = recurrence_period;
    if (recurrence_count !== undefined) params.recurrence_count = recurrence_count;
    if (deadline_date) params.deadline_date = deadline_date;
    if (deadline_type) params.deadline_type = deadline_type;
    if (time_tracking_enabled !== undefined) params.time_tracking_enabled = time_tracking_enabled;
    if (visible_to_organizers && visible_to_organizers.length > 0) {
      params.visible_to_organizers = visible_to_organizers;
    }
    if (is_template !== undefined) params.is_template = is_template;
    if (template_action_id) params.template_action_id = template_action_id;
    if (chapters && chapters.length > 0) {
      params.chapters = chapters;
    }
    if (has_goal !== undefined) params.has_goal = has_goal;
    if (target_audience) params.target_audience = target_audience;
    if (default_individual_goal !== undefined) params.default_individual_goal = default_individual_goal;
    
    await bigquery.query({ query, params });
    
    res.json({ 
      success: true, 
      message: 'Action updated successfully'
    });
  } catch (error) {
    console.error('Error updating action:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PATCH /api/actions/:action_id/status - Update action status (archive/restore)
app.patch('/api/actions/:action_id/status', async (req, res) => {
  try {
    const { action_id } = req.params;
    const { status } = req.body;
    
    if (!action_id || !status) {
      return res.status(400).json({ 
        success: false, 
        error: 'action_id and status are required' 
      });
    }
    
    // Update action status
    // Use CURRENT_DATE() for archived_date when archiving, NULL when restoring
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_actions\`
      SET 
        status = @status,
        archived_date = ${status === 'archived' ? 'CURRENT_DATE()' : 'NULL'}
      WHERE action_id = @action_id
    `;
    
    const params = {
      action_id,
      status
    };
    
    await bigquery.query({ query, params });
    
    res.json({ 
      success: true, 
      message: 'Action status updated successfully'
    });
  } catch (error) {
    console.error('Error updating action status:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/lists - Fetch organizer's turf lists
app.get('/api/lists', async (req, res) => {
  try {
    const { organizer_vanid } = req.query;
    
    if (!organizer_vanid) {
      return res.status(400).json({ success: false, error: 'organizer_vanid is required' });
    }
    
    // Query with JOIN to contacts view (not lumoviz_contacts table) for chapter info
    const query = `
      SELECT 
        l.list_id,
        l.organizer_vanid,
        l.organizee_vanid as vanid,
        l.organizee as contact_name,
        l.action,
        l.action_id,
        l.campaign_id,
        l.progress,
        l.notes,
        l.desired_change,
        l.date_added,
        l.date_pledged,
        l.last_updated,
        l.is_completed,
        l.is_active,
        COALESCE(c.chapter, '') as chapter
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_lists\` l
      LEFT JOIN \`${PROJECT_ID}.${DATASET_ID}.contacts\` c
        ON CAST(l.organizee_vanid AS STRING) = CAST(c.vanid AS STRING)
      WHERE l.organizer_vanid = CAST(@organizer_vanid AS STRING)
        AND (l.is_active = TRUE OR l.is_active IS NULL)
      ORDER BY l.date_added DESC
    `;
    
    const [rows] = await bigquery.query({
      query,
      params: { organizer_vanid }
    });
    
    // Parse JSON progress field
    const lists = rows.map(row => ({
      ...row,
      progress: row.progress ? JSON.parse(row.progress) : {}
    }));
    
    res.json({ success: true, data: lists });
  } catch (error) {
    console.error('Error fetching lists:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/lists - Add person to a list
app.post('/api/lists', async (req, res) => {
  try {
    const { organizer_vanid, organizer_name, contact_vanid, contact_name, action_id, action, desired_change, progress } = req.body;
    
    if (!organizer_vanid || !contact_vanid || !action_id) {
      return res.status(400).json({ 
        success: false, 
        error: 'organizer_vanid, contact_vanid, and action_id are required' 
      });
    }
    
    const query = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_lists\`
      (list_id, organizer_vanid, organizer, organizee_vanid, organizee, action, action_id, progress, desired_change, date_added, last_updated, is_completed, is_active)
      VALUES
      (GENERATE_UUID(), @organizer_vanid, @organizer, @organizee_vanid, @organizee, @action, @action_id, PARSE_JSON(@progress), @desired_change, CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP(), FALSE, TRUE)
    `;
    
    await bigquery.query({
      query,
      params: {
        organizer_vanid,
        organizer: organizer_name || '',
        organizee_vanid: parseInt(contact_vanid),
        organizee: contact_name || '',
        action: action || '',
        action_id,
        progress: JSON.stringify(progress || {}),
        desired_change: desired_change || ''
      },
      types: {
        organizer_vanid: 'STRING',
        organizer: 'STRING',
        organizee_vanid: 'INT64',
        organizee: 'STRING',
        action: 'STRING',
        action_id: 'STRING',
        progress: 'STRING',
        desired_change: 'STRING'
      }
    });
    
    res.json({ success: true, message: 'Person added to list' });
  } catch (error) {
    console.error('Error adding to list:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/lists/:list_id - Update list item
app.put('/api/lists/:list_id', async (req, res) => {
  try {
    const { list_id } = req.params;
    const { progress, notes, desired_change, is_completed } = req.body;
    
    const updates = [];
    const params = { list_id };
    
    if (progress !== undefined) {
      updates.push('progress = PARSE_JSON(@progress)');
      params.progress = JSON.stringify(progress);
    }
    if (notes !== undefined) {
      updates.push('notes = @notes');
      params.notes = notes;
    }
    if (desired_change !== undefined) {
      updates.push('desired_change = @desired_change');
      params.desired_change = desired_change;
    }
    if (is_completed !== undefined) {
      updates.push('is_completed = @is_completed');
      params.is_completed = is_completed;
    }
    
    updates.push('last_updated = CURRENT_TIMESTAMP()');
    
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_lists\`
      SET ${updates.join(', ')}
      WHERE list_id = @list_id
    `;
    
    await bigquery.query({ query, params });
    
    res.json({ success: true, message: 'List item updated' });
  } catch (error) {
    console.error('Error updating list item:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/lists/:list_id - Remove person from list
app.delete('/api/lists/:list_id', async (req, res) => {
  try {
    const { list_id } = req.params;
    
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_lists\`
      SET is_active = FALSE, last_updated = CURRENT_TIMESTAMP()
      WHERE list_id = @list_id
    `;
    
    await bigquery.query({
      query,
      params: { list_id }
    });
    
    res.json({ success: true, message: 'Person removed from list' });
  } catch (error) {
    console.error('Error removing from list:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/contacts - Add a new contact
app.post('/api/contacts', async (req, res) => {
  try {
    const { firstname, lastname, chapter, phone, email, vanid, primary_organizer_vanid } = req.body;
    
    if (!firstname || !lastname) {
      return res.status(400).json({
        success: false,
        error: 'firstname and lastname are required'
      });
    }
    
    // Generate a VAN ID if not provided (use negative numbers for manually added contacts)
    const finalVanId = vanid || `-${Date.now()}`;
    
    // Store contact info in lumoviz_contacts table
    // Note: "contacts" is the view, "lumoviz_contacts" is our table
    const query = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_contacts\`
      (vanid, phone, email, primary_organizer_vanid, created_at, updated_at)
      VALUES (@vanid, @phone, @email, @primary_organizer_vanid, CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP())
    `;
    
    await bigquery.query({
      query,
      params: {
        vanid: finalVanId,
        phone: phone || null,
        email: email || null,
        primary_organizer_vanid: primary_organizer_vanid || null
      }
    });
    
    res.json({ 
      success: true, 
      message: 'Contact extended info added successfully',
      vanid: finalVanId
    });
  } catch (error) {
    console.error('Error adding contact extended info:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/contacts/:vanid - Update an existing contact
app.put('/api/contacts/:vanid', async (req, res) => {
  try {
    const { vanid } = req.params;
    const { phone, email, primary_organizer_vanid } = req.body;
    
    // Update or insert contact info in lumoviz_contacts table
    // Use MERGE to handle both insert and update
    const query = `
      MERGE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_contacts\` T
      USING (SELECT @vanid as vanid) S
      ON T.vanid = S.vanid
      WHEN MATCHED THEN
        UPDATE SET 
          phone = @phone,
          email = @email,
          primary_organizer_vanid = @primary_organizer_vanid,
          updated_at = CURRENT_TIMESTAMP()
      WHEN NOT MATCHED THEN
        INSERT (vanid, phone, email, primary_organizer_vanid, created_at, updated_at)
        VALUES (@vanid, @phone, @email, @primary_organizer_vanid, CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP())
    `;
    
    await bigquery.query({
      query,
      params: {
        vanid,
        phone: phone || null,
        email: email || null,
        primary_organizer_vanid: primary_organizer_vanid || null
      }
    });
    
    res.json({ 
      success: true, 
      message: 'Contact extended info updated successfully'
    });
  } catch (error) {
    console.error('Error updating contact extended info:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/meetings - Log a conversation/meeting
app.post('/api/meetings', async (req, res) => {
  try {
    const { 
      contact_vanid, 
      contact_name, 
      organizer_vanid, 
      meeting_type, 
      date, 
      notes, 
      chapter,
      person_type,
      purpose,
      values,
      difference,
      resources,
      commitment_asked_yn,
      commitment_made_yn,
      commitment_what,
      catapults,
      shared_purpose_constituency_stance,
      shared_purpose_constituency_how,
      shared_purpose_change_stance,
      shared_purpose_change_how,
      leadership_tag,
      did_share_story,
      what_shared,
      action_id
    } = req.body;
    
    if (!contact_vanid || !organizer_vanid || !meeting_type || !date) {
      return res.status(400).json({
        success: false,
        error: 'contact_vanid, organizer_vanid, meeting_type, and date are required'
      });
    }
    
    const query = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_meetings\`
      (
        vanid, 
        organizer_vanid, 
        meeting_type, 
        datestamp, 
        chapter, 
        notes, 
        person_type,
        purpose,
        values,
        difference,
        resources,
        commitment_asked_yn,
        commitment_made_yn,
        commitment_what,
        catapults,
        shared_purpose_constituency_stance,
        shared_purpose_constituency_how,
        shared_purpose_change_stance,
        shared_purpose_change_how,
        leadership_tag,
        did_share_story,
        what_shared,
        action_id,
        created_at
      )
      VALUES (
        @vanid, 
        @organizer_vanid, 
        @meeting_type, 
        @datestamp, 
        @chapter, 
        @notes,
        @person_type,
        @purpose,
        @values,
        @difference,
        @resources,
        @commitment_asked_yn,
        @commitment_made_yn,
        @commitment_what,
        @catapults,
        @shared_purpose_constituency_stance,
        @shared_purpose_constituency_how,
        @shared_purpose_change_stance,
        @shared_purpose_change_how,
        @leadership_tag,
        @did_share_story,
        @what_shared,
        @action_id,
        CURRENT_TIMESTAMP()
      )
    `;
    
    await bigquery.query({
      query,
      params: {
        vanid: parseInt(contact_vanid),
        organizer_vanid: organizer_vanid.toString(),
        meeting_type,
        datestamp: date,
        chapter: chapter || null,
        notes: notes || null,
        person_type: person_type || null,
        purpose: purpose || null,
        values: values || null,
        difference: difference || null,
        resources: resources || null,
        commitment_asked_yn: commitment_asked_yn || null,
        commitment_made_yn: commitment_made_yn || null,
        commitment_what: commitment_what || null,
        catapults: catapults && catapults.length > 0 ? catapults : null,
        shared_purpose_constituency_stance: shared_purpose_constituency_stance || null,
        shared_purpose_constituency_how: shared_purpose_constituency_how || null,
        shared_purpose_change_stance: shared_purpose_change_stance || null,
        shared_purpose_change_how: shared_purpose_change_how || null,
        leadership_tag: leadership_tag || null,
        did_share_story: did_share_story || false,
        what_shared: what_shared || null,
        action_id: action_id || null
      }
    });
    
    res.json({ 
      success: true, 
      message: 'Conversation logged successfully'
    });
  } catch (error) {
    console.error('Error logging conversation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/organizer-goals - Fetch organizer's personal goals
app.get('/api/organizer-goals', async (req, res) => {
  try {
    const { organizer_vanid } = req.query;
    
    if (!organizer_vanid) {
      return res.status(400).json({ success: false, error: 'organizer_vanid is required' });
    }
    
    const query = `
      SELECT 
        organizer_vanid,
        action_id,
        goal_value,
        campaign_id,
        created_at,
        updated_at
      FROM \`${PROJECT_ID}.${DATASET_ID}.organizer_goals\`
      WHERE organizer_vanid = @organizer_vanid
    `;
    
    const [rows] = await bigquery.query({
      query,
      params: { organizer_vanid }
    });
    
    res.json({ success: true, data: rows });
  } catch (error) {
    console.error('Error fetching organizer goals:', error);
    // If table doesn't exist, return empty array
    if (error.message?.includes('Not found: Table')) {
      console.warn('[organizer-goals] Table does not exist yet, returning empty array');
      res.json({ success: true, data: [] });
    } else {
      res.status(500).json({ success: false, error: error.message });
    }
  }
});

// POST /api/organizer-goals - Save/update organizer's personal goals
app.post('/api/organizer-goals', async (req, res) => {
  try {
    const { organizer_vanid, action_id, goal_value, campaign_id } = req.body;
    
    if (!organizer_vanid || !action_id || goal_value === undefined) {
      return res.status(400).json({ 
        success: false, 
        error: 'organizer_vanid, action_id, and goal_value are required' 
      });
    }
    
    console.log(`[organizer-goals] Saving goal for organizer ${organizer_vanid}, action ${action_id}, goal ${goal_value}`);
    
    // Use MERGE to insert or update the goal
    const query = `
      MERGE \`${PROJECT_ID}.${DATASET_ID}.organizer_goals\` AS target
      USING (
        SELECT 
          @organizer_vanid AS organizer_vanid,
          @action_id AS action_id,
          @goal_value AS goal_value,
          ${campaign_id ? '@campaign_id' : 'CAST(NULL AS STRING)'} AS campaign_id,
          CURRENT_TIMESTAMP() AS updated_at
      ) AS source
      ON target.organizer_vanid = source.organizer_vanid 
        AND target.action_id = source.action_id
      WHEN MATCHED THEN
        UPDATE SET 
          goal_value = source.goal_value,
          campaign_id = source.campaign_id,
          updated_at = source.updated_at
      WHEN NOT MATCHED THEN
        INSERT (organizer_vanid, action_id, goal_value, campaign_id, created_at, updated_at)
        VALUES (source.organizer_vanid, source.action_id, source.goal_value, source.campaign_id, CURRENT_TIMESTAMP(), source.updated_at)
    `;
    
    const params = {
      organizer_vanid,
      action_id,
      goal_value
    };
    
    if (campaign_id) {
      params.campaign_id = campaign_id;
    }
    
    await bigquery.query({ query, params });
    
    res.json({ success: true, message: 'Goal saved successfully' });
  } catch (error) {
    console.error('Error saving organizer goal:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================
// LEADER HIERARCHY ENDPOINTS
// ============================================

// Get leader hierarchy for an organizer
app.get('/api/leader-hierarchy', async (req, res) => {
  try {
    const { organizer_vanid } = req.query;
    
    let query, queryOptions;
    
    if (organizer_vanid) {
      // Filter by specific organizer (backward compatibility)
      query = `
        SELECT 
          leader_vanid,
          parent_leader_vanid,
          organizer_vanid,
          created_date,
          updated_date
        FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_leader_hierarchy\`
        WHERE organizer_vanid = @organizer_vanid
        ORDER BY created_date DESC
      `;
      queryOptions = {
        query,
        params: { organizer_vanid }
      };
    } else {
      // Fetch ALL hierarchy entries (needed for nested leader display)
      // This allows us to show full hierarchy trees (e.g., if Sam adds Courtney,
      // and Courtney leads Cedric, we can show Cedric under Courtney)
      query = `
        SELECT 
          leader_vanid,
          parent_leader_vanid,
          organizer_vanid,
          created_date,
          updated_date
        FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_leader_hierarchy\`
        ORDER BY created_date DESC
      `;
      queryOptions = { query };
    }
    
    const [rows] = await bigquery.query(queryOptions);
    
    res.json(rows);
  } catch (error) {
    console.error('Error fetching leader hierarchy:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add or update a leader in hierarchy
app.post('/api/leader-hierarchy', async (req, res) => {
  try {
    const { organizer_vanid, leader_vanid, parent_leader_vanid } = req.body;
    
    if (!organizer_vanid || !leader_vanid) {
      return res.status(400).json({ 
        error: 'organizer_vanid and leader_vanid are required' 
      });
    }
    
    // Use MERGE to insert or update
    const query = `
      MERGE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_leader_hierarchy\` AS target
      USING (
        SELECT 
          @organizer_vanid AS organizer_vanid,
          @leader_vanid AS leader_vanid
      ) AS source
      ON target.organizer_vanid = source.organizer_vanid
         AND target.leader_vanid = source.leader_vanid
      WHEN MATCHED THEN
        UPDATE SET 
          parent_leader_vanid = @parent_leader_vanid,
          updated_date = CURRENT_TIMESTAMP()
      WHEN NOT MATCHED THEN
        INSERT (organizer_vanid, leader_vanid, parent_leader_vanid, created_date, updated_date)
        VALUES (source.organizer_vanid, source.leader_vanid, @parent_leader_vanid, CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP())
    `;
    
    await bigquery.query({
      query,
      params: {
        organizer_vanid,
        leader_vanid,
        parent_leader_vanid: parent_leader_vanid || null
      }
    });
    
    res.json({ success: true, message: 'Leader hierarchy saved' });
  } catch (error) {
    console.error('Error saving leader hierarchy:', error);
    res.status(500).json({ error: error.message });
  }
});

// Remove a leader from hierarchy
app.delete('/api/leader-hierarchy', async (req, res) => {
  try {
    const { organizer_vanid, leader_vanid } = req.body;
    
    if (!organizer_vanid || !leader_vanid) {
      return res.status(400).json({ 
        error: 'organizer_vanid and leader_vanid are required' 
      });
    }
    
    // Delete where the person calling this is either:
    // 1. The organizer_vanid (top-level owner), OR
    // 2. The parent_leader_vanid (direct manager)
    const query = `
      DELETE FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_leader_hierarchy\`
      WHERE leader_vanid = @leader_vanid
        AND (organizer_vanid = @organizer_vanid OR parent_leader_vanid = @organizer_vanid)
    `;
    
    const [result] = await bigquery.query({
      query,
      params: { organizer_vanid, leader_vanid }
    });
    
    console.log('[DELETE leader-hierarchy] Deleted rows:', result?.numDmlAffectedRows || 0);
    
    res.json({ 
      success: true, 
      message: 'Leader removed from hierarchy',
      rowsDeleted: result?.numDmlAffectedRows || 0
    });
  } catch (error) {
    console.error('Error deleting leader from hierarchy:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// ORGANIZER MAPPING ENDPOINTS
// ============================================

// Get all organizer mappings
app.get('/api/organizer-mapping', async (req, res) => {
  try {
    const query = `
      SELECT 
        primary_vanid,
        preferred_name,
        alternate_vanids,
        name_variations,
        email,
        notes,
        created_at,
        updated_at
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_organizer_mapping\`
      ORDER BY preferred_name ASC
    `;
    
    const options = {
      query,
      location: 'US',
    };
    
    const [rows] = await bigquery.query(options);
    res.json(rows);
  } catch (error) {
    console.error('Error fetching organizer mappings:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add or update an organizer mapping
app.post('/api/organizer-mapping', async (req, res) => {
  try {
    const { 
      primary_vanid, 
      preferred_name, 
      alternate_vanids, 
      name_variations, 
      email, 
      notes 
    } = req.body;
    
    if (!primary_vanid || !preferred_name) {
      return res.status(400).json({ 
        error: 'primary_vanid and preferred_name are required' 
      });
    }
    
    // Convert arrays to proper format for BigQuery
    // Ensure all VAN IDs are strings
    const alternateVanidsStr = alternate_vanids && alternate_vanids.length > 0
      ? `[${alternate_vanids.map(id => `"${String(id)}"`).join(', ')}]`
      : 'NULL';
    
    const nameVariationsStr = name_variations && name_variations.length > 0
      ? `[${name_variations.map(name => `"${String(name)}"`).join(', ')}]`
      : 'NULL';
    
    // Build the query - handle NULL values properly for arrays
    const query = `
      MERGE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_organizer_mapping\` T
      USING (SELECT 
        "${String(primary_vanid)}" AS primary_vanid,
        "${preferred_name.replace(/"/g, '\\"')}" AS preferred_name,
        ${alternateVanidsStr !== 'NULL' ? alternateVanidsStr : 'CAST(NULL AS ARRAY<STRING>)'} AS alternate_vanids,
        ${nameVariationsStr !== 'NULL' ? nameVariationsStr : 'CAST(NULL AS ARRAY<STRING>)'} AS name_variations,
        ${email ? `"${String(email).replace(/"/g, '\\"')}"` : 'CAST(NULL AS STRING)'} AS email,
        ${notes ? `"${String(notes).replace(/"/g, '\\"')}"` : 'CAST(NULL AS STRING)'} AS notes,
        CURRENT_TIMESTAMP() AS updated_at
      ) S
      ON T.primary_vanid = S.primary_vanid
      WHEN MATCHED THEN
        UPDATE SET 
          preferred_name = S.preferred_name,
          alternate_vanids = S.alternate_vanids,
          name_variations = S.name_variations,
          email = S.email,
          notes = S.notes,
          updated_at = S.updated_at
      WHEN NOT MATCHED THEN
        INSERT (primary_vanid, preferred_name, alternate_vanids, name_variations, email, notes, created_at, updated_at)
        VALUES (S.primary_vanid, S.preferred_name, S.alternate_vanids, S.name_variations, S.email, S.notes, CURRENT_TIMESTAMP(), S.updated_at)
    `;
    
    console.log('Executing organizer mapping query:', query);
    
    await bigquery.query({
      query,
      location: 'US',
    });
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error saving organizer mapping:', error);
    console.error('Error details:', error.message);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete an organizer mapping
app.delete('/api/organizer-mapping/:vanid', async (req, res) => {
  try {
    const { vanid } = req.params;
    
    if (!vanid) {
      return res.status(400).json({ error: 'vanid is required' });
    }
    
    const query = `
      DELETE FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_organizer_mapping\`
      WHERE primary_vanid = "${vanid}"
    `;
    
    await bigquery.query({
      query,
      location: 'US',
    });
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting organizer mapping:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/organizer-details/:vanid - Get organizer details (turf, team_role)
app.get('/api/organizer-details/:vanid', async (req, res) => {
  try {
    const { vanid } = req.params;
    
    if (!vanid) {
      return res.status(400).json({ success: false, error: 'vanid is required' });
    }
    
    const query = `
      SELECT 
        vanid,
        turf,
        team_role
      FROM \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      WHERE vanid = @vanid
    `;
    
    const [rows] = await bigquery.query({
      query,
      params: { vanid: vanid }
    });
    
    if (rows.length === 0) {
      return res.json({ 
        success: true, 
        data: { vanid, turf: null, team_role: null }
      });
    }
    
    res.json({ success: true, data: rows[0] });
  } catch (error) {
    console.error('Error fetching organizer details:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/organizer-details/:vanid - Update organizer details (turf, team_role)
app.put('/api/organizer-details/:vanid', async (req, res) => {
  try {
    const { vanid } = req.params;
    const { turf, team_role } = req.body;
    
    if (!vanid) {
      return res.status(400).json({ success: false, error: 'vanid is required' });
    }
    
    const query = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.org_ids\`
      SET 
        turf = @turf,
        team_role = @team_role
      WHERE vanid = @vanid
    `;
    
    await bigquery.query({
      query,
      params: {
        vanid: vanid,
        turf: turf || null,
        team_role: team_role || null
      }
    });
    
    res.json({ 
      success: true, 
      message: 'Organizer details updated successfully',
      data: { vanid, turf, team_role }
    });
  } catch (error) {
    console.error('Error updating organizer details:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================================================
// CAMPAIGN MANAGEMENT ENDPOINTS
// ============================================================================

// GET /api/campaigns - Get all campaigns with their goal types and milestones
app.get('/api/campaigns', async (req, res) => {
  try {
    // Fetch campaigns
    const campaignsQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaigns\`
      WHERE status = 'active'
      ORDER BY start_date DESC
    `;
    const [campaigns] = await bigquery.query(campaignsQuery);

    // Fetch all goals (includes both org-wide and chapter-level)
    const goalsQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_goals\`
    `;
    const [goals] = await bigquery.query(goalsQuery);

    // Fetch all milestones
    const milestonesQuery = `
      SELECT *
      FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_milestones\`
      ORDER BY milestone_date ASC
    `;
    const [milestones] = await bigquery.query(milestonesQuery);

    // Build nested structure matching frontend expectations
    const campaignsWithDetails = campaigns.map(campaign => {
      // Get all goals for this campaign (both org-wide and chapter-specific)
      const allGoalsForCampaign = goals.filter(g => g.campaign_id === campaign.campaign_id);
      
      // Separate org-wide goals from chapter-specific goals
      const orgWideGoals = allGoalsForCampaign.filter(g => g.chapter === null);
      const chapterGoals = allGoalsForCampaign.filter(g => g.chapter !== null);

      // Group milestones by label and build goalTypeTargets object
      const milestonesByDate = new Map();
      milestones
        .filter(m => m.campaign_id === campaign.campaign_id)
        .forEach(m => {
          const dateKey = m.milestone_date?.value || m.milestone_date;
          if (!milestonesByDate.has(dateKey)) {
            milestonesByDate.set(dateKey, {
              id: m.milestone_id,
              date: dateKey,
              description: m.milestone_label,
              goalTypeTargets: {}
            });
          }
          const milestone = milestonesByDate.get(dateKey);
          if (m.goal_type && m.target_value) {
            milestone.goalTypeTargets[m.goal_type] = m.target_value;
          }
        });

      return {
        id: campaign.campaign_id,
        name: campaign.campaign_name,
        description: campaign.description,
        startDate: campaign.start_date?.value || campaign.start_date,
        endDate: campaign.end_date?.value || campaign.end_date,
        chapters: campaign.chapters || [],
        parentCampaignId: campaign.parent_campaign_id,
        campaignType: 'parent', // Default
        createdDate: campaign.created_at,
        goalTypes: orgWideGoals.map(g => {
          // Find all chapter-specific goals for this goal type
          const chapterGoalsForType = chapterGoals.filter(cg => cg.goal_type === g.goal_type);
          const chapterGoalsMap = {};
          chapterGoalsForType.forEach(cg => {
            if (cg.chapter) {
              chapterGoalsMap[cg.chapter] = cg.target_value;
            }
          });
          
          return {
            id: g.goal_type,  // Use goal_type as the ID (e.g., 'team_members')
            name: g.goal_name,
            description: '',
            totalTarget: g.target_value,
            unit: g.goal_type === 'pledges' ? 'pledges' : 
                  g.goal_type.includes('1on1') ? '1:1s' : 'members',
            dataSource: g.goal_type === 'pledges' ? 'pledges' :
                        g.goal_type === 'membership_1on1s' ? 'meetings_membership' :
                        g.goal_type === 'leadership_1on1s' ? 'meetings_leadership' : 'manual',
            level: 'organization',
            chapterGoals: Object.keys(chapterGoalsMap).length > 0 ? chapterGoalsMap : undefined
          };
        }),
        milestones: Array.from(milestonesByDate.values())
      };
    });

    res.json({ success: true, data: campaignsWithDetails });
  } catch (error) {
    console.error('Error fetching campaigns:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/campaigns - Create a new campaign
app.post('/api/campaigns', async (req, res) => {
  try {
    const {
      campaign_name,
      description,
      start_date,
      end_date,
      chapters,
      parent_campaign_id,
      goal_types,
      milestones
    } = req.body;

    if (!campaign_name || !start_date || !end_date) {
      return res.status(400).json({
        success: false,
        error: 'campaign_name, start_date, and end_date are required'
      });
    }

    const campaign_id = campaign_name.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '') + '_' + Date.now();

    // Insert campaign
    const campaignQuery = `
      INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaigns\`
      (campaign_id, campaign_name, description, start_date, end_date, chapters, parent_campaign_id, status)
      VALUES (@campaign_id, @campaign_name, @description, @start_date, @end_date, @chapters, @parent_campaign_id, 'active')
    `;

    await bigquery.query({
      query: campaignQuery,
      params: {
        campaign_id,
        campaign_name,
        description: description || '',
        start_date,
        end_date,
        chapters: chapters || ['All Chapters'],
        parent_campaign_id: parent_campaign_id || null
      }
    });

    // Insert goal types if provided
    if (goal_types && goal_types.length > 0) {
      for (const gt of goal_types) {
        // Insert org-wide goal
        const goal_id = `${gt.id}_${campaign_id}_${Date.now()}`;
        const gtQuery = `
          INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_goals\`
          (goal_id, campaign_id, goal_type, goal_name, target_value, chapter)
          VALUES (@goal_id, @campaign_id, @goal_type, @goal_name, @target_value, NULL)
        `;
        await bigquery.query({
          query: gtQuery,
          params: {
            goal_id,
            campaign_id,
            goal_type: gt.id,  // Simple name like 'team_members'
            goal_name: gt.name,
            target_value: gt.totalTarget,
            // chapter is NULL for org-wide goals
          }
        });
        
        // Insert chapter-specific goals if provided
        if (gt.chapterGoals && Object.keys(gt.chapterGoals).length > 0) {
          for (const [chapter, chapterTarget] of Object.entries(gt.chapterGoals)) {
            const chapter_goal_id = `${gt.id}_${campaign_id}_${chapter}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const chapterGtQuery = `
              INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_goals\`
              (goal_id, campaign_id, goal_type, goal_name, target_value, chapter)
              VALUES (@goal_id, @campaign_id, @goal_type, @goal_name, @target_value, @chapter)
            `;
            await bigquery.query({
              query: chapterGtQuery,
              params: {
                goal_id: chapter_goal_id,
                campaign_id,
                goal_type: gt.id,
                goal_name: gt.name,
                target_value: chapterTarget,
                chapter: chapter
              }
            });
          }
        }
      }
    }

    // Insert milestones if provided
    if (milestones && milestones.length > 0) {
      for (const m of milestones) {
        // Milestones in your schema are one row per goal type
        const goalTypeTargets = m.goalTypeTargets || {};
        for (const [goalType, targetValue] of Object.entries(goalTypeTargets)) {
          const milestone_id = `${m.id}_${goalType}_${Date.now()}`;
          const mQuery = `
            INSERT INTO \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_milestones\`
            (milestone_id, campaign_id, milestone_date, milestone_label, goal_type, target_value)
            VALUES (@milestone_id, @campaign_id, @milestone_date, @milestone_label, @goal_type, @target_value)
          `;
          await bigquery.query({
            query: mQuery,
            params: {
              milestone_id,
              campaign_id,
              milestone_date: m.date,
              milestone_label: m.description || '',
              goal_type: goalType,
              target_value: targetValue
            }
          });
        }
      }
    }

    res.json({
      success: true,
      data: { campaign_id }
    });
  } catch (error) {
    console.error('Error creating campaign:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/campaigns/:campaign_id - Update a campaign
app.put('/api/campaigns/:campaign_id', async (req, res) => {
  try {
    const { campaign_id } = req.params;
    const {
      campaign_name,
      description,
      start_date,
      end_date,
      chapters,
      parent_campaign_id,
      status
    } = req.body;

    const updateQuery = `
      UPDATE \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaigns\`
      SET 
        campaign_name = @campaign_name,
        description = @description,
        start_date = @start_date,
        end_date = @end_date,
        chapters = @chapters,
        parent_campaign_id = @parent_campaign_id,
        status = @status,
        updated_at = CURRENT_TIMESTAMP()
      WHERE campaign_id = @campaign_id
    `;

    await bigquery.query({
      query: updateQuery,
      params: {
        campaign_id,
        campaign_name,
        description,
        start_date,
        end_date,
        chapters: chapters || [],
        parent_campaign_id: parent_campaign_id || null,
        status: status || 'active'
      }
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error updating campaign:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/campaigns/:campaign_id - Delete a campaign
app.delete('/api/campaigns/:campaign_id', async (req, res) => {
  try {
    const { campaign_id } = req.params;

    // Delete related goals
    await bigquery.query({
      query: `DELETE FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_goals\` WHERE campaign_id = @campaign_id`,
      params: { campaign_id }
    });

    // Delete related milestones
    await bigquery.query({
      query: `DELETE FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaign_milestones\` WHERE campaign_id = @campaign_id`,
      params: { campaign_id }
    });

    // Delete the campaign
    await bigquery.query({
      query: `DELETE FROM \`${PROJECT_ID}.${DATASET_ID}.lumoviz_campaigns\` WHERE campaign_id = @campaign_id`,
      params: { campaign_id }
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting campaign:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Catch-all handler: send back React's index.html file for any non-API routes
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.listen(port, '0.0.0.0', () => {
  // console.log(`ðŸš€ Carolina Federation Symposium API Server running on port ${port}`);
  // console.log(`ðŸ“Š API endpoints available at http://localhost:${port}/api/`);
  // console.log(`ðŸŒ Health check: http://localhost:${port}/api/health`);
});
